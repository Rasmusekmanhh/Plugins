using System.Globalization;
using Turbo.Plugins.Default;
using System.Linq;
using SharpDX.DirectInput;

using System;
using System.Text;
using System.Collections.Generic;

namespace Turbo.Plugins.Zy
{
    public class MapKnowledge : BasePlugin, IInGameTopPainter, IKeyEventHandler, INewAreaHandler
    {
        public enum MapType {Normal, FourCorner, Special};

        public enum Direction { Top = 0, Right = 1, Down = 2, Left = 3 };

        public class MapTemplate
        {
            public MapTemplate()
            {
                Name_ = "unknown";
            }
            public MapTemplate(string Name, string SceneName, MapType Maptype)
            {
                Name_ = Name;
                SceneName_ = SceneName;
                Maptype_ = Maptype;
            }

            public string Name_ { get; }
            public string SceneName_;
            public MapType Maptype_;
        }
        public class SceneType
        {
            public SceneType()
            {
                Name_ = "unknown";
            }
            public SceneType(string Name, char Type)
            {
                Name_ = Name;
                Type_ = Type;
            }

            public string Name_ { get; }
            public char Type_;
        }
        public class FourCornerTemplate
        {
            public FourCornerTemplate()
            {
                Type1_ = '0';
                Type2_ = '0';
                Type3_ = '0';
                Type4_ = '0';
            }
            public FourCornerTemplate(FourCornerTemplate New)
            {
                Type1_ = New.Type1_;
                Elbow1_ = New.Elbow1_;
                Type2_ = New.Type2_;
                Elbow2_ = New.Elbow2_;
                Type3_ = New.Type3_;
                Elbow3_ = New.Elbow3_;
                Type4_ = New.Type4_;
                Elbow4_ = New.Elbow4_;
                Result_ = New.Result_;
                ResultDeadend_ = New.ResultDeadend_;
                ResultSmaleTile_ = New.ResultSmaleTile_;
            }
            public FourCornerTemplate(char Type1, bool Elbow1, char Type2, bool Elbow2, char Type3, bool Elbow3, char Type4, bool Elbow4, char Result, bool ResultDeadend, bool ResultSmaleTile)
            {
                Type1_ = Type1;
                Elbow1_ = Elbow1;
                Type2_ = Type2;
                Elbow2_ = Elbow2;
                Type3_ = Type3;
                Elbow3_ = Elbow3;
                Type4_ = Type4;
                Elbow4_ = Elbow4;
                Result_ = Result;
                ResultDeadend_ = ResultDeadend;
                ResultSmaleTile_ = ResultSmaleTile;
            }

            public char Type1_ { get; }
            public bool Elbow1_;
            public char Type2_ { get; }
            public bool Elbow2_;
            public char Type3_ { get; }
            public bool Elbow3_;
            public char Type4_ { get; }
            public bool Elbow4_;
            public char Result_;
            public bool ResultDeadend_;
            public bool ResultSmaleTile_;
        }
        public class SceneEntry
        {
            public SceneEntry()
            {
                SceneName = "unknown";
                Mapname = "unknown";
                PosX = 0;
                PosY = 0;
                X = 0;
                Y = 0;
                Type = '0';
                entrance = false;
                exit = false;
                deadend = false;
                elbow = false;
            }
            public SceneEntry(string SceneName_, string Mapname_, float PosX_, float PosY_, int X_, int Y_, char Type_)
            {
                SceneName = SceneName_;
                Mapname = Mapname;
                PosX = PosX_;
                PosY = PosY_;
                X = X_;
                Y = Y_;
                Type = Type_;
                entrance = false;
                exit = false;
                deadend = false;
                elbow = false;
            }
            public SceneEntry(string SceneName_, string Mapname_, float PosX_, float PosY_, int X_, int Y_, char Type_, bool entrance_, bool exit_, bool deadend_, bool elbow_)
            {
                SceneName = SceneName_;
                Mapname = Mapname;
                PosX = PosX_;
                PosY = PosY_;
                X = X_;
                Y = Y_;
                Type = Type_;
                entrance = entrance_;
                exit = exit_;
                deadend = deadend_;
                elbow = elbow_;
            }
            public SceneEntry(SceneEntry Copy)
            {
                SceneName = Copy.SceneName;
                Mapname = Copy.Mapname;
                PosX = Copy.PosX;
                PosY = Copy.PosY;
                X = Copy.X;
                Y = Copy.Y;
                Type = Copy.Type;
                entrance = Copy.entrance;
                exit = Copy.exit;
                deadend = Copy.deadend;
                elbow = Copy.elbow;
            }

            public string SceneName { get; set; }
            public string Mapname { get; set; }
            public float PosX { get; set; }
            public float PosY { get; set; }
            public int X { get; set; }
            public int Y { get; set; }
            public char Type { get; set; }
            public bool entrance { get; set; }
            public bool exit { get; set; }
            public bool deadend { get; set; }
            public bool elbow { get; set; }
        }
        public class TemplateMatch
        {
            public TemplateMatch()
            {
                match_ = false;
                matchR_ = false;
                matchD_ = false;
                matchDR_ = false;
            }
            public TemplateMatch(FourCornerTemplate Template, bool match, bool matchR, bool matchD, bool matchDR, SceneEntry Scene, SceneEntry SceneR, SceneEntry SceneD, SceneEntry SceneDR)
            {
                Template_ = Template;
                match_ = match;
                matchR_ = matchR;
                matchD_ = matchD;
                matchDR_ = matchDR;
                Scene_ = Scene;
                SceneR_ = SceneR;
                SceneD_ = SceneD;
                SceneDR_ = SceneDR;
            }
            public FourCornerTemplate Template_;
            public bool match_;
            public bool matchR_;
            public bool matchD_;
            public bool matchDR_;
            public SceneEntry Scene_;
            public SceneEntry SceneR_;
            public SceneEntry SceneD_;
            public SceneEntry SceneDR_;
        }
        public class ByCoordinate : IComparer<SceneEntry>
        {
            public int Compare(SceneEntry x, SceneEntry y)
            {
                if (x.PosX > y.PosX)
                    return 1;
                else if (x.PosX < y.PosX)
                    return -1;
                else
                {
                    if (x.PosY > y.PosY)
                        return 1;
                    else if (x.PosY < y.PosY)
                        return -1;
                    else
                        return 0;
                }
            }
        }
        public class ByY : IComparer<MatchingResult>
        {
            public int Compare(MatchingResult x, MatchingResult y)
            {
                if (x.y > y.y)
                    return 1;
                else if (x.y < y.y)
                    return -1;
                else
                    return 0;
            }
        }
        public class ByX : IComparer<MatchingResult>
        {
            public int Compare(MatchingResult x, MatchingResult y)
            {
                if (x.x > y.x)
                    return 1;
                else if (x.x < y.x)
                    return -1;
                else
                    return 0;
            }
        }
        public class ByPercent : IComparer<Tuple<char, double>>
        {
            public int Compare(Tuple<char, double> x, Tuple<char, double> y)
            {
                if (x.Item2 < y.Item2)
                    return 1;
                else if (x.Item2 > y.Item2)
                    return -1;
                else
                    return 0;
            }
        }
        public class LayoutEntry
        {
            public LayoutEntry()
            {
                Count = 0;
                Layout = "";
            }
            public LayoutEntry(int Count_, string Layout_)
            {
                Count = Count_;
                Layout = Layout_;
            }
            public int Count;
            public string Layout;
        };
        public class CodedMap
        {
            public CodedMap(string Name_, string CodedString_)
            {
                Name = Name_;
                CodedString = CodedString_;
                IsSplit = false;
                Layouts = new List<LayoutEntry>();
            }
            public void Split()
            {
                int pos = 0;
                while (pos < CodedString.Count())
                {

                    int Count = 0;
                    string Layout = "";
                    int i = 1;
                    while (i < 10)//up to 10^10
                    {
                        if (pos + i >= CodedString.Count())
                        {
                            IsSplit = true;
                            return;
                        }
                        int Numbers = CodedString.Substring(pos, i).Count(c => Char.IsNumber(c));
                        if (i != Numbers)
                        {
                            i--;
                            break;
                        }
                        i++;
                    }
                    if (i > 0)
                    {
                        Count = Int32.Parse(CodedString.Substring(pos, i));
                    }
                    else
                    {
                        Count = 1;
                    }
                    pos = pos + i;
                    i = 0;
                    int Arrows = 0;
                    while (i < 1000)
                    {
                        if (pos + i >= CodedString.Count())
                        {
                            IsSplit = true;
                            return;
                        }
                        if (CodedString[pos + i] == '↑' || CodedString[pos + i] == '→' || CodedString[pos + i] == '↓' || CodedString[pos + i] == '←')
                        {
                            Arrows++;
                        }
                        if (Arrows >= 3 || Char.IsNumber(CodedString[pos + i]))//1 instantly, 1 as the exit and break on the third 
                        {
                            break;
                        }
                        i++;
                    }
                    Layout = CodedString.Substring(pos, i);
                    Layouts.Add(new LayoutEntry(Count, Layout));
                    pos = pos + i;
                }
            }
            public string Name;
            public string CodedString;
            public List<LayoutEntry> Layouts;
            public bool IsSplit;
        };
        public class MatchingResult
        {
            public MatchingResult()
            {
                x = 0;
                y = 0;
                Data = new List<Tuple<char, double>>();
            }
            public MatchingResult(int x_, int y_, List<Tuple<char, double>> Data_)
            {
                x = x_;
                y = y_;
                Data = Data_;
            }
            public int x;
            public int y;
            public List<Tuple<char, double>> Data;
        }
        private List<MapTemplate> MapTemplateList = new List<MapTemplate>{

            new MapTemplate("Zoltun Kulle","a2dun_zolt", MapType.Normal),

            new MapTemplate("Hell Rift", "a4dun_hellportal", MapType.Special),

            new MapTemplate("Battlefields", "x1_pand_ext_120_edge", MapType.FourCorner),

            new MapTemplate("Blue Cave", "a2dun_cave_flooded", MapType.Normal),

            new MapTemplate("Brown Cave", "a2dun_cave", MapType.Normal),

            new MapTemplate("Cave", "trdun_cave", MapType.Normal),

            new MapTemplate("Cathedral", "trdun_cath", MapType.Normal),

            new MapTemplate("Spikey Cave", "x1_bogcave", MapType.Normal),

            new MapTemplate("Church", "p6_church", MapType.Normal),

            new MapTemplate("Corvus", "x1_catacombs", MapType.Normal),

            new MapTemplate("Crater", "a3dun_crater", MapType.Special),

            new MapTemplate("Crypt", "trdun_crypt", MapType.Normal),

            new MapTemplate("Desert", "px_desert_120_border", MapType.FourCorner),

            new MapTemplate("Festering", "px_festeringwoods_border", MapType.FourCorner),

            new MapTemplate("Forgotten Ruins", "a2dun_zolt_random", MapType.Normal),

            new MapTemplate("Green Cave", "px_cave_a", MapType.Normal),

            new MapTemplate("Halls of Agony", "a1dun_leor", MapType.Normal),

            new MapTemplate("Ice Cave", "a3dun_icecaves", MapType.Normal),

            new MapTemplate("Keeps", "a3dun_keep", MapType.Normal),

            new MapTemplate("Pest Tunnel", "x1_abattoir", MapType.Normal),

            new MapTemplate("Sewers", "a2dun_swr", MapType.Normal),

            new MapTemplate("Sewers (water)", "a2dun_aqd", MapType.Normal),

            new MapTemplate("Shocktowers", "x1_fortress", MapType.Normal),

            new MapTemplate("Shrouded Moors", "p6_moor", MapType.FourCorner),

            new MapTemplate("Eternal Woods (no snow)", "p4_forest_coast", MapType.FourCorner),

            new MapTemplate("Eternal Woods", "p4_forest_snow", MapType.FourCorner),

            new MapTemplate("Spaghetti", "x1_pand_hexmaze", MapType.Normal),

            new MapTemplate("Spider Cavern", "a2dun_spider", MapType.Normal),

            new MapTemplate("Spire", "a4dun_spire_corrupt", MapType.Normal),

            new MapTemplate("Westmarch", "x1_westm", MapType.Normal),

            new MapTemplate("Westmarch Ruins", "x1_westm", MapType.Normal),
            };
        private List<FourCornerTemplate> FourCornerTemplateList = new List<FourCornerTemplate>
        {
            new FourCornerTemplate('╦', false, '╦', false,
                                   '╩', false, '╩', false, '═', false, false),
            new FourCornerTemplate('╠', false, '╣', false,
                                   '╠', false, '╣', false, '║', false, false),

            new FourCornerTemplate('╠', false, '╣', false,
                                   '╚', false, '╝', false, '╵', true, false),
            new FourCornerTemplate('╚', false, '╝', false,
                                   '0', false, '0', false, '╵', true, true),
            new FourCornerTemplate('╔', false, '╦', false,
                                   '╚', false, '╩', false, '╶', true, false),
            new FourCornerTemplate('╔', false, '0', false,
                                   '╚', false, '0', false, '╶', true, true),
            new FourCornerTemplate('╔', false, '╗', false,
                                   '╠', false, '╣', false, '╷', true, false),
            new FourCornerTemplate('╔', false, '╗', false,
                                   '0', false, '0', false, '╷', true, true),
            new FourCornerTemplate('╦', false, '╗', false,
                                   '╩', false, '╝', false, '╴', true, false),
            new FourCornerTemplate('╗', false, '0', false,
                                   '╝', false, '0', false, '╴', true, true),

            new FourCornerTemplate('╠', false, '╚', true ,
                                   '╚', false, '╩', false, '╚', false, false),
            new FourCornerTemplate('╠', false, '╗', true ,
                                   '╚', false, '╩', false, '╚', false, false),
            new FourCornerTemplate('╔', true , '╣', false,
                                   '╩', false, '╝', false, '╝', false, false),
            new FourCornerTemplate('╝', true , '╣', false,
                                   '╩', false, '╝', false, '╝', false, false),
            new FourCornerTemplate('╔', false, '╦', false,
                                   '╠', false, '╝', true , '╔', false, false),
            new FourCornerTemplate('╔', false, '╦', false,
                                   '╠', false, '╔', true , '╔', false, false),
            new FourCornerTemplate('╦', false, '╗', false,
                                   '╚', true , '╣', false , '╗', false, false),
            new FourCornerTemplate('╦', false, '╗', false,
                                   '╗', true , '╣', false , '╗', false, false),

            new FourCornerTemplate('╔', true , '╣', false,
                                   '╚', true , '╣', false, '╣', false, false),
            new FourCornerTemplate('╝', true , '╣', false,
                                   '╗', true , '╣', false, '╣', false, false),
            new FourCornerTemplate('╠', false, '╗', true ,
                                   '╠', false, '╝', true , '╠', false, false),
            new FourCornerTemplate('╠', false, '╚', true ,
                                   '╠', false, '╔', true , '╠', false, false),
            new FourCornerTemplate('╔', true , '╗', true ,
                                   '╩', false, '╩', false, '╩', false, false),
            new FourCornerTemplate('╝', true , '╚', true ,
                                   '╩', false, '╩', false, '╩', false, false),
            new FourCornerTemplate('╦', false, '╦', false,
                                   '╗', true , '╔', true , '╦', false, false),
            new FourCornerTemplate('╦', false, '╦', false,
                                   '╚', true , '╝', true , '╦', false, false),
        };
        private List<SceneType> SceneTypeList = new List<SceneType>{
            new SceneType("_ew_",'═'),
            new SceneType("_ns_",'║'),

            new SceneType("_n_",'╵'),
            new SceneType("_e_",'╶'),
            new SceneType("_s_",'╷'),
            new SceneType("_w_",'╴'),

            new SceneType("_ne_",'╚'),
            new SceneType("_nw_",'╝'),
            new SceneType("_se_",'╔'),
            new SceneType("_sw_",'╗'),

            new SceneType("_nsw_",'╣'),
            new SceneType("_nse_",'╠'),
            new SceneType("_new_",'╩'),
            new SceneType("_sew_",'╦'),

            new SceneType("_nsew_",'╬'),
        };
        private List<CodedMap> CodedMaps = new List<CodedMap>
        {
            new CodedMap("Battlefields", "5→╦╣↑╚╝←╔╣╵╚║↑→═╗╠═→╵2→╦╦→╚╝11↑╠╔╣↑╝7→╩╔╣↑╝↑║╦╝║↑╶←╩╷╚╗═←→══╣╔→╵↓╝═╔╣↓╶←╚╗═╠↑╵12↑╠╔╦→╝2→╝╔╦╴╚→↑╠╷══╗↓17↑╠╔╗╣↓2←╩╷╔╚╗↓←╚╗╦╝╶←↓║║╣║↓╶18↓╠╗╚╣↓→╗╣║║↓╶6↑╠╔╗╩→→╗╩╗╝╶←↓╩╗╚═→╶11↓╠╣↑╚╝←╔╠╗╵║↓→╩╷╝╔╗↓↑╔╩╷╗╚→→╗╠╗╵║↓↓╚╗╩╴═←4↓╠╗╚╩→←╚║╔╦→╵→╦╗╚╩→↑╔╩╷══→→╝╗╚╣↑╶↓║╝╩╗←╶→╣╷╚╝║↑2←╚╔╝╣╷←↑╦╴═╚╔→↑║╣╷╚║↑←═╚╠╷═→↓╝╠╷║╝←←╚╔╩╷═→←╦╵╔║╝←↑╗═╚╠╷→↓║╚╣╷║↓2→╗║╩╗↓╶→╦╗╵║║↓2←═╦╵╚╔→←╦╵╚╔═→2→══╦╴╚→↓╚═╩╷╝↑2←═╔╝╩↑╶2←╔║╠╴╚→↓║║╠═→╵7→╩╔╦→╝←╚╦╴╔║↓↓╝╚╣╔→╶←╔╠╴║║↓←╔╩═╝↑╶←═╔╩═→╶→╝╔╝╣↑╶→══╗╣╵←←╚║║╦╴←↓║║╚╩↑╴→╗╣╚╗↓╶↓╠╴╝╚║↑↑║╔═╦╴↓↓╠╴╝═╚↑↑╗═╔╣↓╶4→╩╔╗╣↓←╠║╔╗↓╵↓║╠╝║↑╵↓╝╩╷╚║↑→═╦╴╝═←↓╣╚═╝↑╶→╩║╔═→╴↑╔═╦═→╵↓║╝╠╷║↓2↑╔╝╦╴═←←╠╷║╝╚↑→═╝╗╩↑╶↓╚═╩╷═→2↑╔═╝╠╷→↓╩╴═╔║↓↑╗╚╠╷═→→╝╦═╗↓╶←╠╷╚══→↓╣║║╝╶←→╝╗╩╷╚↑←╔╝╦╵╚↑↓╝╔║╩→╶→╝║╦╗↓╶→╝╔╗╠╴↓↓╩╴═══←↓╚╣╷╚═→→╣╷║╝╚↑↑╔╝║╠╷→←══╦║↓╶→╝╣╷══←3→╩╔╗╩→←═╠╷╚╗↓↑╠║╔╗╴↓3→╦╗╚╣↓↑╠╗╴╚╔→↑╔╗║╠╴↓←═╦║╚→╶↓║╚═╦╴↓↓║║╝╩╷←↓╩╗╚╝↑╶2→╝╦╗║↓╶←╠╔╝╗╵←↓╚╩╔═→╴↑║║╦═→╶↓╠╗╵╚═→↑║╔╝╣╷←↑╦╗╚╝↑╶↓╚╣╷╝╔↓↑╣╔═╗↓╶←╩║╗╚↑╶→╝║╗╦╵←←══╦╵╔↓↑║╗╠║↑╵→╝╣╷╚╗←↑║╗╠╷╝←↓║║║╣╵←↑╔══╩↑╴←╔║╚╦→╵←╚╔═╣╷↓↑║║╔╣↑╵←╔╝╠╗╵←2↓║╩╝║↑╶→╦═╗╵║↓3↓╠╦→╚╝2↑╔╝╠╷╝↑←═╔╝╠↑╵↑╔═╝╦╴←→╣╔╗╚→╵↑╦╗╚═→╶→═╝╣╷═←↑╦╝╗═←╶→═╗║╠╴↓←╩╷╚╗╚↑↑║╣║╗←╶↓╠╴╝══←→╗╚╦╗╵↓→═╗╩╗↓╶→╝╦╝╗←╶↑║╗═╦↓╶→═╝╣╷╚↑↓║╣╚╝↑╶→╣║╔╝↑╵↓╝═╠╷╝←↑╗╔╝╦↓╶↓╚╗╝╦╵←←╩╷╚║║↑→╝╗╩╗←╶←╩╷═══←↓║╚╩╔→╴←╚╦╴╔╝←↓║╚╣║↑╵←══╚╠╷→←═╚║╣╷←↑╗═╠╷╝←→═╣╷╚╗↓↓╣╚╗║↓╶↑╦╴╚╔═→→╣╗╵══←↑╔╗╚╦→╵↓╝╔║╠→╵←══╠╷╝←↑╔╣╷╚╝↑←╔╣╵═╚↑↓╚══╣╷↓→╗╩╝║↑╶←══╩╷╚↑↓╠╝║╗╵←↑╣╗═╔↓╶←═╔╠╴╚→↑╗══╦╵←←╩╗╚╔→╶←╚╗╦║↓╶↓╚╗╩╴╔↓←╦║╚═→╶→╝║╣╗←╶→╗╝╦╵╚↑←═══╩↑╶←╔║╚╣╷↓↓╚╝║╠↑╴↑╦═╗╚→╶↑║║╣╷╚↑↓║╩╴╚║↑↑╦═╝╗←╶"),
            new CodedMap("Blue Cave", "↑║╣╗╔╬↓╶↓╩═╗╩╣╷↓╶╶→╦╴╝╔╠╴╩╴←↑╗╠╔╩╣╷╴╵←↑╗╩╦╴╠↑╚←═╦╩╴╶╔╠╴↓↓║╬╗╚╩→╶↓║╠╦╴╠╝↓→╗╠╣╷╩╝←←╔╠╴╣║╠╴↓╶↓╚╦╣↑╩╝╶"),
            new CodedMap("Brown Cave", "→╩╷╣╷╚╝╠↑╴←╔╠╦→╚╣╵"),
            new CodedMap("Cathedral", "6→╦╣↑╚╝←═╠╷╝╔↓←╩╷╚║║↑7↓╠╣↑╚╝2→╦╦→╚╝↓╝╠╷║╝←↑║╦═╝↑╶←╚╗╠╷║↓↓║╣╚╝↑╶→╝╦╝║↑╶←═╚╦═→╶16↑╠╔╣↑╝→╝║╠╷╗↓→═╩╗╴═←←╚╗╠╔→╵→═╗╚╣╷↓↓╩╴╚║║↑14→╩╔╣↑╝←╚╗╔╣↓╶↓╠╴╝╔╝←4→╩╔╦→╝↓╝╔╝╩↑╶5↓╠╗╚╩→→╩╷╝║╔→4↓╠╦→╚╝5↑╠╔╗╩→↓║╩╗╝╶←5→╩╔╗╣↓6↑╠╔╗╣↓3↑╗╠╔╝↑╵↑╔╩╷╗╝←→═╣╷╚╗↓2→╝╣╷╚║↑↑║╔╦╝↑╵→╩╷═╝╗←←╔╝╚╣↑╶←═╚╣╗←╶→╝╦╗╚→╶↑║║║╠╷→↑╠╷═╝║↑↓╚═╝╣╷←→╣╷╚═╗↓↓╣╚╝╔→╶2→╦╗╚╣↓→╝╗╚╠╷→↑║╦╴═╚↑←╩╷╔╚╗↓2↓║╝╩║↑╶2↑╔╝╣╗←╶2↑╦╝╗╚↑╶2←╦╝╶══←→╣╷║╝╚↑2→═╝║╣↑╶←═╦╚╗↓╶↓╣║╝╶╔↓→╗╝╦╝╶←↑╠╷╝║║↑↑╔╝╦╗↓╶2←╔║╣╝╶←↑║║╠╷╝↑→╗╚╩╔→╴↑╗╔║╣↓╶↑╗╠╔═→╵→╦╴╚╗╝←←══╚╠↑╴→═╗╩╝↑╶←╔╝╩╷╚↑↑╔╝╦╴╚↑↑╗╚╠╷╝↑←╔╚═╩╷→→╗╩╝║↑╶←╔║║╩→╶↑╠╔╝║↑╴→╗║╝╩↑╶↑╗╚╣╷╚↑4→╩╔╗╩→→╣╷║╚═→↓╣║╝╶═←3↑╠╔╦→╝→╗╝═╩↑╶→╝╦╗║↓╶→╩╷╗╝╔↓←══╩╷═←→══╣╷║↓2↑║╦╗║↓╶↑╗╩╔╝↑╶↓╝╩║║↑╶↑╗╩╔═→╶↑║╗╠╗╵←→═╣╷╝═←←╚╗╚╠╷→←═╚╣╷═←↑║╗╦║↓╶↓║╣╝╶═←↓╝╦╚═→╶↑║║╣╷╚↑↑╗╚║╦→╶→══╝╦→╶→╝╔╩╷╗↓←═╠╷╚╗↓↑╗╚║╠╷→←╦╚╗╚→╶↑║╗╔╣↓╶↓╚╣╷╝╔↓↑╦╗║║↓╶↑╔╣╗╵╚↑→╝║║╠╷→3↑║╗╠║↑╵↑╦═══→╶↓╝╚╣╷═←↑╗╠║╗╵←↑╗╠╗╵╔↓↑╠╷╗║╝←→╩║╗╴╔↓←═╠╷╚═→↓║║╚╦╴↓←═╔╩╗↓╶5↓╠╗╚╣↓→╣╷╚╝║↑↑╠╷╗║╚→←╩║╔═→╶←╚╗╦╝╶←→╝╔═╦╴↓↑╣╷══╚↑←╦╝╶═╚↑↑╦╴══╚↑↓║╚╝╠╷→←╩╷╔╝╚↑→╝╣╷═╚↑↑╗╦╵╚║↑→╣╷║╚╝↑↑╗╚╦╴╚↑→═╝╦╗↓╶"),
            new CodedMap("Cave", "3↑║╬╷═→╶→╣╠╣╷╴╵╔╝←↑║║╣╠║↑╴╶↑║╦╴╔╣║↓╶↑║╣╗╔╬↓╶↓╠╗╠╣╵╚→↓╩═╗╩╣╷↓╶╶→╦╴╝╔╠╴╩╴←↑╔╩╔╦→╩╴←═╬║↑╵╶↓╚╝╠╷╩╔→╴↑╔╦╣↑╚╣╵↑╗╠╔╩╣╷╴╵←↑╗╩╦╴╠↑╚↓╣╝╠╷╠╝←→╣║╠╷╣╷║↓╵↑╣╣║║╣↑╶╶╶←╚║║╬╔→╴╶↓║╬╴╝╔╠↓←═╦╩╴╶╔╠╴↓↓║╠╗╩╩→╶↓║╬╗╚╩→╶↑╠╠╔╝╔→╴╴4←═╬╷║↓╶→╝╗╩╠╦→╴╶╶←═╬↑╝╠╷╚↓╩╦╴║╝╶═←↓║╠╦╴╠╝↓→╗╠╦╴╚╩→→╣╣║╦╝↑╵╶╶→╝╦╴═╩╠╷→╶↑╦═╝╣╠↑╴╶╶2↑║╬╷╴═←↑╔═╩╷╦╴╣↓╶↑╔╦╦╴╚╩→2←═╬╗╵╔╩←←╠╷║╠═╩╷→╵2→═╬╷═→╵→╗╠╣╷╩╝←←╔╠╴╣║╠╴↓╶↑╣║╗╩╠╷→╶╶↓╝╬╷╚══→╶→╩╷╦╴╝═╦↓╶↑╔╦╗╠╩→╵↓╣╠╴║╠╴║↓╶↓║╬╴║↓╶←╩╷╦╵╦╝╶═←←╩╦╴╦╚╔↓↓║╬═→╵╶→╩╷╣╷╚╝╠↑╴2↓║╬╴╵═←2←═╬╷╵═←↓╚╣║╔╩↑╴╵←╔╩╴═╦╠╴↓╶↑║╠╠╗╴╴╦↓╶→╝╣╗╦╩╶←↑╗╩╬↑╴╔╚↓║║╠╴╣╣╵╶←↓╠╗╩╩╝↑╶↓║╩╝╠╠╷→╴╶←╩║╔╩╷╣╷↓╶↑╦╩╷╩╷╝║↑╶→╣╠╔╝╦→╴╵╶↓║╝╠╷╣╩╴╶←↓╚╣╷╚╦╴╣↓╶↓╝╦╣╚╦╴↓╶╶←╚╦╴╩╷═╩╷←↓╝╬╷╝╔╩←↓╩╴═╠╦╴╵╔↓↓║╬╴╝╔╩←←╠╷║╝╩╷╠↑╵→═╬║↑╴╵←╔╠╦→╚╣╵←╔╣╠╴╣╚→╶╶↓╚╦╣↑╩╝╶"),
            new CodedMap("Church", "4→╗╝╔↓3↓╚╝╔→2→═╝╔→→══╝↑↑╔═╗↓4→══╗↓4↑╔╗║↓3→╗╝═←2↑╗╚╔→←═╚╔→↑║╗╔↓2↑╗══←2←═╚╗←2→╗║╚→5↑║╔═→3↑║╔╝↑6↓╚╝║↑3→╝║║↑3→╝╗╚↑2↑╔══→5↑╗╔╝←5←╚╔═→6←╔╚═→2←╚╗╔↓3←╚╔╝↑2→═╗║↓2→╗╚═→2↑║╗═←↓║╝╚↑2↓║╚╝↑2↓╚═╗↓2↓║╝═←4↑╗╚╗←↑╗╔║↓4↓╚╗║↓2↓╚═╝↑2←╔╝═←2←╚╗╚↑4↓╝╚║↑3↓║╚═→2→╝╔╝↑3↑╗═╔↓4→═══→→═╝║↑3↑║║╗←→╝║╔→→╗╚╝↑3→╗╚╗↓←╔║║↓4→═╝╗←3↑╔═╝↑↑╗═╚↑3↑║║╔→2↓╝╚╗←↓║╚╗↓2↓╝═╔↓3→╝╔═→←═╔╝←2←╔╝╔↓2←══╔↓2↑╔╝╗←3←╔╚╗↓↓╝═╚↑2↑╔╝╔→2←╚║╗←↓╝╔║↓2↓╚╗╚→2↓╝══←↓╚╗╝←←═╔║↓←╚║╔→→╗║║↓3↑╔╝║↑3→═╗╝←↑╔╗╚→2↑║║║↑←╔║╝←←═══←"),
            new CodedMap("Corvus", "2←═╩╗←╶→═╣╷║↓↓╝╔╝═╚║╔→←╦║╚→╶↑╗═╔╚╗╝═←↑╠╠╔═╝↑╗╝↓╚═╦╴↓2→╦╗╵║↓↓╝═╩↑╶←╔║║║║╝╚↑←╔╩╴╚↑←╔╚╦╴↓↑║╣╔→╶↑╔╝║╗╚╔═→↓║╣╚→╶→═╝╦╴←3→═╝╣↑╶↑║╔╝║║╗╚↑→╝╔══╗║╚→→╩╔╣╗╝══←←╔╝╦↓╶↓╚═╝╔╝╔╗↓←╚╦╴═←↑╔╗╚╗╝══←→╦╗╠╝╚╗║↓←╦╝╔╠╝╔╚→←╔╩╗↓╶↑╗╔╣↓╶↑║║║║╔╗╚→→╝╦╝↑╶→╗╚═╗║╝═←↑╔╣╷║↓←══╔╚═╗║↓←═╚║╔╗╚═→↓║╩╴╔↓↑║╣╷═←↑╗╚╗╔╝╚╗←↓║╚╩╷→↓║╝╩╷←→╦╴║║↓←╩╗╔╩╚╗╔↓↓╩╴╚║↑→╗╚╝╔╗║╝←↑╠╷═╩╔╣↑╝↑╗╔╝╚║╔═→→═╗║╣╣↓╔╚↓║║╣╵←2↓╣║╝╶←→╗╠╴╚→↑╦═╝↑╶↓╝═╩╷←↓╩═╝↑╶2↓╚═╩↑╴4↑╣╷╔║↓2↑╣╗╚↑╶2↓╝╔╚═╗╝╔↓2↑╣║╔→╶2←═╔║║║║║↓↓║╚╩↑╴←╩╷═╔↓↑║╦╝↑╶←╩╷╔╠╗╚╣↓↑╗╦║↓╶←═══╚╗╚╗←↓╚══╗╚╗║↓↓║╝══╚╗╚↑↑╣╗╦╚╚║╗←2←═╔╣╵←→═╝╔╝╗╚║↑↓╚╗╝╔╚╗╝←←═╔║╚═╗╝←←╩╗╔╩╔╝═←↓╚╝╔═╗╝╔↓←═╩╷╚↑→╗╝╔║╝═╔↓→╗╚╣╷↓←╩╷╚╗←↓╣╝╔╩╚║╔→→═══╝║╔╗↓→╗║╚═╗╚═→←═╔╝╚║╗═←→╣╷╚╗↓↓╝═╔╚╗╝╔↓↑╔╝║║╗══←→╗╝╔║╝══←→╗╝╔╝╔╚═→↑║║╔╗╚═╗↓↓╣╵╔║↓↓╚╝╔═╝╗═←↑╣╷═╚↑↑╗╔║╝╔╝═←↓╝╦╚→╶←╚╔═╗╚══→←╦║╣╝╶╔╩←↓╚╝╠╷→→╝╗═╔║║║↓↑╠╔╗╣║╝╔↓↓║║║║╝═╔↓↑╗╩╷╔↓←╚╣╷╚↑→═╗║╚╝╔═→↑╔╝╦→╶←╚╔╝║╔═╝↑→═╗║╚╗╝═←↑║╗╚╗╚║╔→←╚║╗╚║╔╗↓↑╗╚║╗╚║║↑↓╠╗╠╝║║║↓→╝╔╣╷↓↑║║║╔╝║╗←↑║╔════╗↓↓╝╚╣╷←←╠╷╚╗↓→═╝║╗╚╗╔↓↓╚╝╔╝╔╝╗←↑║╠╷╗↓↓║║╝══╔║↓←╩╦╝╗═←╔╚↓╚═══╗╝╔↓←╠╷╝╚↑↓║╝╚╗╚╔╝↑2↑╗═╩╷←↑║╗══╚║╔→→╗║╚╦╦→╚╝↑╦╗╚→╶↓╚╩╷╝↑↑╔╗║║║║╚→2↑║║╠╷→←╔╚═╦╗╚╣↓←╠╷╝╔↓←╚╔╝║╔╗╚→→╝╔╗║╚╝╔→↓╣╵╔╝←↑╠╷╗║↓→╗╝═╔╝╔║↓↑╦╝╔→╶↓╠╗╠╝║╝═←→╝╗═╚╔══→↓╚╣╔→╵↑║╔╦→╵↑╔╣╗╵←←╔║╚═╗╝╔↓←╠╗╵╩╗╠↑╚←═╚║╗╔╝╚↑↑╔╗║╣╝╔╠↓↑║║║║╔═╗↓←╔╠═→╵↓╝╠║↑╵↑╠║╗╴←↑╣╗╠║║╗╚←←══╔╚══╗↓↓║╝╔╝═╔║↓←═╦║↓╶↓╠╗╠╝╝╔╚→↑╗╩║↑╶→═╝╔╗║╚═→→═╗╩→╶←╦╝╔╠╚╗╚→→═╗╣╵←↑║║╦→╶→═╗║║║╝╚↑↑║╔╣↑╵←╔╚══╗╝╔↓↓║╝═╚╗╔╝←→╗╚╝╠╔╦→╝→═╗╠╴↓↓╚═╝╔═╝╔→←╔║║╝═╚╗←→╗╝╦╵←→╗║║╝═╔║↓↓║╝╔╝╚╗╔↓↑║╔╝╔╝║╗←←╦╝╔╠║╣↓╶←╚╗╦↓╶←═╚╔═══╝↑→╦╗╚╣║╩╴←→═╣╷╝←→╝║║║╗╔╝←←╔╝═╚╔╝║↑←╩╷═╦╝╔╠↓←╔║╚╗╚╗╚→↑╣╷╚╣╗╠↑╚↓╝╔╩→╶←═╦╵╔↓↓╚╗╣↓╶→═╝╔╗║║╚→↑╗╔║╠╗╚╩→↑║╣║↑╶↓║╚╗╝═╚╗←↓║║╝╦╝╠↑╚→╗╝╔╠╗╩╝←→══╗╚╝╔╝↑↓╚╝╠↑╴↑╗═══╚╔═→"),
            new CodedMap("Crypt", "↓╩╗╚═→╶↑║╗╩╗╦╚←↓╝╚║╦╴←8↓╠╗╚╣↓←╚║╠╔╦→╝↓║║╝╠╷╠╗╵↓→═╗╣╝╔╠↓↑║╗╠╷║↓↑╠╷╗║╝←→╦╴║║╚→↑╦═╗╠╝║↑╵╶↑╔═╗╚╦╦╴╵↓↓╠╴║╝╚↑↓╩═╣╷║╚╝↑╶↑╗╔╝╩╷╩║↑╶→══╝╣↑╶2→╩╔╗╩→↓╩╝╠╷╗║╚→╶→═╝╣╗╦╚←↑╠╔╦→╝→══╦╗╚╩→↑║╦╴╚╔╝╣↑╶2↓╣╝╔╩╔╚→↓║╩╗╝╶←↓╠╗╚╣║╝←←╩╷╔╣╵╔║║↓←╠╔╝╔→╵2↓║╝╠╷╝←→╦╗╚╣╝╔↓2↓╩╴══╔↓8↓╠╣↑╚╝↑╠╔╦╗╝╚→↑╣╗╦╚╔║↓→═╗╣╝╔╩←↓║╚═╩╷→5↑╠╔╗╣↓↑╣╔╝╗←╶←╚╣╷══←2↓╣╝╔╩═╚↑→╗╠══→╵→╩╔╦→╝→╝╦╣╷╚╝║↑╶←╦╝╔╩╔╝←←╚╗╦╝╔╠↓↑╗╠╷║║↓→╣╷╝╔╚═╣╷↓3→╦╣↑╚╝↓╩═╝║╣║↑╶╶↓╝╠╷╝╚↑3→╦╗╚╣↓←═╚╦══╦╴↓╶↓║╩╴╔╩═╗↓╶↑╗═╦╝╶←4→╩╔╣↑╝→╝╔╩╔╦→╝←╔║╠╴║╩╴═←←╦╝╔╩═╔↓→╗╚╦╗╚╩→↑║╔╝╠╷═╣╷↓2↓║╚╦╗╚╣↓←═╔║╣╵←7↑╠╔╣↑╝4↓╠╗╚╩→↑║╗╚╠↑╴2↑╣╗╚╔→╶↓╣╝╔╩╚╗←2←══╩╔→╶4↓╠╦→╚╝↓╩╗╝╶═←←╠╷╚═╗╝╦╵←↓╣╝╶═╔↓←╔╝╩╗╦╚←↑╗══╩╔╩↑╴╶3↓╚╗╣╝╔╩←↓╣╵╠║╗╵╔║↓←╚╗╚╠╷→↓╠╗╵║╚→←╠╔═╩╷══→╵→╦╗╚╩→↑║╗╦╵╩╔╝↑╶↓║╝╚╣↑╶←╠╷╚╗║↓←═╚╠╔╦→╝→╝║╠╔╦→╝2↓╠╗╚╩╗║↓↓╚╣╷╩╝╔╝↑╶↓╩══╝↑╶→═╗╠╗╚╣↓→╣╷║╝╚↑←╚║║╠╷→↓║╝╩╗╦╚←←╔╩╗╣║╝╶╶←↓╣╚╝║↑╶↓╝═╦╝╔╠↓↑║╠╷╗╚→↓╣╚═╝↑╶↓╚╗╣╵╔↓←╦╝╔╠║╝←→╝║╦╴══╩↑╶↑║╔═╦╴↓→╦═╗╵╝╔╣↓╶↓║╩═╝╣╷╚↑╶↑║╗═╦╩╗↓╶╶↓╣║║╠╝╔→╵╶←╩╷╔╩══╗↓╶↑╔╝╠╔╦→╝←╚║╣╷╚↑→═╩╗╴╚↑2↓╚╩╷╗╚→↓╚╗╠╗╚╣↓↑╠╔╣╗╝═←←═╦║╝╶←↓╠╗╚╩╝║↑↓║╝═╩↑╶2↑║╗╦╝╔╩←→╣╷╝═╚↑↓╚╗╣╝╔╠↓←╠╔═╗↓╵↑╣╗╠╗╚═←↓║╚╣╷║╠╝↑╵↑╠╷═╗╩╗║↓╶↓╚═╗╠╴↓←╠╷║║╚→↓╚═╗╩╴←↓║╝╦║↓╶←══╔╠╴↓←╚╣╷╔║↓↓╣╝╔╠╝═←→╩╔╦═╝↑╝↓║║╠╝↑╵↓╣╠╝║╔╝↑╵╶↑╠╔╣╔╝↑╝↓╚═╦╗╚╣↓→╝╣╷╚║↑→╣╷║╚╝↑←═╔╠╴╚→↑╠╔╦╝╗╝←↑╔╝╗╩╷╦╝╶←↓╣╚╝╔→╶↓╣╝╶╦╵═══←→╗║╠╗╚╣↓←╩╔╝║╠╗╴←╶↓╠═╝╗╵←↓╠╗╚╣╚╝↑↓║║╝╠╷↓↓║╩═╝↑╶↑╦╗╚╝↑╶←╩╷═╔╝←↓╚╣╷╣╵╔║║↓→╗╩╗║↓╶↑║╔╣╗╵←↑║╔╦╴╚→←╩╔╝╔╝╣╷←╶→═╣╷║║↓→╦╴╝═╔↓↑║║╣╗╦╚←←╚╣╷═╚↑→╗║╝╩↑╶"),
            new CodedMap("Desert", "↓║╚╣╷╚→→══╝╠╷→9↓╠╣↑╚╝↑║╣╗═←╶→╩╷╗║╝←↑╔═╝╠╷→←╩╗╚╔→╶2→═══╦→╵↓╩╴╚║╗←3↓╠╗╚╩→↑║╦╴╔║↓10↑╠╔╗╣↓↑╦╴╔╝═←↑║╗╚╠╷→→╝╠╷╗╚→7↑╠╔╦→╝←╠╷╚══→→═╣╗╵═←↑╔╝╣╗←╶↑╦══╗↓╶↑╔╝║╠╷→→╣║║║↑╵↓╠╴╝╚║↑↑╗══╦↓╶↓╩══╝↑╶3→╦╗╚╣↓↑╔╝║╣╷←2↓╠╦→╚╝12↑╠╔╣↑╝↑║╔╩╷═→→╣║╗╵╔↓2←╚╣╷╚║↑7→╩╔╣↑╝2→╦╦→╚╝→╝╔╣╷║↓→╩╗╴═╚↑→═══╦╴↓3→╦╗╚╩→←╚║║╠╷→↑╣╷╚║╔→6↓╠╗╚╣↓↑╦╴══╚↑3→╩╔╦→╝2←╔╣╵╚║↑↓╩╴══╔↓4→╩╔╗╣↓←╚╠╷╝║↑←╔╣╚╗↓╶→╩╷╝╔╝↑↑╔╩╷╝║↑↑║╔╝╣╷←↓╣║╚╗↓╶→╝║║╣╷←↓║╝╔╩→╶←╠╷╝╔║↓←╚║╦╗↓╶→╣╷╚═╗↓↑╗╚║╠╷→←╦╝╶╔╚→↑╦╝║║↑╶→╣╔╗║╵↓↓╝═╩║↑╶↓╝═╔╩╴←2↓║╣╵╚║↑←╚╣╷═╔↓↑║╠╷╝║↑→╝║╗╩↑╶→╣╷╚╗╚→→╣╷║╝╚↑←══╔╠→╵↓╚╝║╠╷→↑║╠╗╴╔↓↑╔═╣║↑╵↓║╝╚╣╷←↓╩╗║╝╶←→╝╦╗╚→╶↑║║╗╦↓╶↑╠╷═╝╗←←╚╣╷╚╗←2→╦╣↑╚╝↑╔╩╷╗║↓↓╚═╝╣↑╶↓╝╠╷╝═←↓╠╴╝═╔↓→╣╷╝═╔↓→╗║╝╠╷↓←╔╣╵══←→╗╚╩╷╝↑↑╦══╝↑╶↓║╣╚═→╶←═╦╚═→╶↑║╔╗╠→╵←═╩╷╚╗←↑╗╔║╠╴↓2↓╝╩╷╚║↑↓╝╩╷╚╗←→═╗╚╩╷→←═╚║╦→╶↓║╝╠║↑╵←═══╩↑╶→╗╚╦═→╵→═╗║╩╴←→╣╔╗╚→╵←╠╷║╝╚↑←╠╗╵═╔↓←╚╗╩║↑╶↑╗╚╦═→╶↑╠║╗╴╚↑↑╔═╣╷║↓↓╚╗╠╴╝←←══╔╩╴←↓╚╝║╣╷←↓║╝═╠↑╵↑╦╴═╔║↓←╦╵═╚╗←←╔║╣║↓╶3↑╠╔╗╩→→═╝║╠↑╴↓║║╝╩╷←↓╚╝╔╦╴↓→╝║╣║↑╶↑╗╩╗═←╶↓╝╔╩╗↓╶↓║║╠╗╵↓→╝║╗╠↑╵←╠╷╚╗╝←↑╗╚║╣↑╶→╦╗╵║╚→↓╝═╠╷║↓→═╦╴╚╗↓"),
            new CodedMap("Eternal Woods", "←╦╚═╝↑╶↑║║╠╔→╴6↓╠╣↑╚╝↓║║╠╴╝←↓║║╚╦→╵←═╩╷╔╚→2→╣╗╵╚╔→4↑╠╔╦→╝←╚║╗╠╷↓↑║║╣╷═←→╗║╚╣╷↓↑╣╷═╔╚→7↑╠╔╣↑╝↑╦═╗║↓╶2↑╗═╦╝╶←→══╦╴╚→↓╚╗╩╗↓╶8↑╠╔╗╣↓↑╗╚╠╷╝↑←╚║╣╗←╶↓║╝╚╣╷←←╚╣╷╔╝←2↑╗╚╦╝↑╶3↑╠╔╗╩→↓╣║║╝╶←←╠╷╚╗╚→↑║╗╠╷║↓↓║╣╵╚║↑↓╝╩║╗←╶2→╩╷╗╝═←↑║║╣║↑╶↓╩╝╔═→╶→╝╣║║↑╶↓║║╚╣↑╵2←═╚╣╗←╶→╗╝╦╝╶←2←╠╷╚═╗↓←═╔╝╦↓╶↓╝╚║╣╷←2←═╚╔╩╷→↓╠╦→╚╝→╗║╝╠╷↓→╦╦→╚╝ 3↓╠╗╚╩→→╦╗╚╣↓←╚╔╝╣╷←→╣╷║║║↓↓║╝╩║↑╶→╩╷╝║╗←↓║╝╦╚→╶←╔╚╦╴╚→↑╗╚╣╷╚↑←╚║╣╷╚↑→╗╝╔╩→╶3↓╠╗╚╣↓2→╩╔╣↑╝←╚╣╗═←╶↑╗╚╠╷═→→═╝╔╩↑╴←══╔╩╴←↓║╩╴╚║↑→╣╷║╝╚↑↓╠╴║╝╚↑2→╣╷╚╗╝←2→╩╔╦→╝↓║╝═╠╷↓2↑╗═╚╠╷→←╚╦═╗↓╶↓╝╔╝╩↑╶→═╗╚╩↑╴↑╔═╗╣╵←↑╗╔╣╚→╶↓╠╴╝═╔↓↑║╔═╦╴↓→╗║╩╗↓╶↑║╗╔╣↓╶3→╦╗╚╩→↓╚╩╷╗╚→↓║╚╩╷╝↑2←══╩╔→╶←═══╠↑╵→╝╦══→╶→═╩╷╝║↑←╦╝╶══←↓║╚╣╷╚→→╗║╩═→╶↓╝╠╷╚╗↓↓╝╩╷╔╚→↑╗╦╝╶═←↓╩╝║╗←╶→╩╔══→╴↑╣╔╗╚→╶←╦╵╔╝╚↑→╝╦╴╚║↑→═╩╔═→╴→╩╔╗╩→↓╚╗╠╴╚→↓╚╣║╗╵←↓╝═╔╩→╶↓╚╝╔╩╷→↓╚╗╩╴╔↓←═╔╩╗↓╶↑║╗╚╦→╶←╔║║╣↓╶←╔╩╴══←↑╔╗║╩→╶↓╝╚╗╠↑╵↑╗╠╷╝╔↓↑║╗╚╣↑╶←╚║║╠╷→↑╣╷═╔╝←←╚╗╩╷╚↑↑╠╷╗║╝←→═╝╦╴╚↑→╝╔╣╗╵←↓║║║╣╵←↓╚╝║╣╷←←═╔║╠╴↓"),
            new CodedMap("Eternal Woods (no snow)", "←╦╚═╝↑╶2↓╠╣↑╚╝↓║║╠╴╝←↓║║╚╦→╵→╣╗╵╚╔→↑║║╣╷═←↑╣╷═╔╚→6↑╠╔╣↑╝↑╦═╗║↓╶6↑╠╔╗╣↓←╚║╣╗←╶↑║╗╠╷║↓↓╝╩║╗←╶2→╩╷╗╝═←↑║║╣║↑╶↑╠╔╗╩→↓╩╝╔═→╶→╝╣║║↑╶↓║║╚╣↑╵→╗╝╦╝╶←2←╠╷╚═╗↓←═╔╝╦↓╶↓╝╚║╣╷←2←═╚╔╩╷→↓╠╦→╚╝→╦╦→╚╝ →╦╗╚╣↓→╣╷║║║↓→╩╷╝║╗←←╔╚╦╴╚→↑╗╚╣╷╚↑←╚║╣╷╚↑2↑╠╔╦→╝2↓╠╗╚╣↓→╩╔╣↑╝↑╗╚╠╷═→↓║╩╴╚║↑→╣╷║╝╚↑↓╠╴║╝╚↑2→╣╷╚╗╝←2→╩╔╦→╝↓║╝═╠╷↓2↑╗═╚╠╷→←╚╦═╗↓╶→═╗╚╩↑╴↑╔═╗╣╵←↓╠╴╝═╔↓↑║╔═╦╴↓→╗║╩╗↓╶↑║╗╔╣↓╶↓╚╩╷╗╚→↑╗╚╦╝↑╶↓║╚╩╷╝↑→╝╦══→╶↓╝╠╷╚╗↓↓╝╩╷╔╚→→╩╔══→╴↑╣╔╗╚→╶←╦╵╔╝╚↑→═╩╔═→╴↓╚╣║╗╵←↓╝═╔╩→╶↓╚╗╩╴╔↓↑║╗╚╦→╶←╔║║╣↓╶↓╝╚╗╠↑╵↑║╗╚╣↑╶←╚║║╠╷→↑╣╷═╔╝←←╚╗╩╷╚↑↑╠╷╗║╝←↓║║║╣╵←←═╔║╠╴↓"),
            new CodedMap("Festering", "13↓╠╗╚╣↓12↓╠╣↑╚╝↓╝╠╗╵╚↑←═╚╠╷╝↑←═╔╚╦→╵→╝╦╗║↓╶↓╚╝║╣↑╶↓╝╩╷╚║↑→╗╩╴═╚↑5↑╠╔╦→╝↑╗╠║║↑╵2→╗╚╩║↑╴12↑╠╔╗╣↓→╝╦╝║↑╶3↓╠╦→╚╝6↓╠╗╚╩→↑║╔╗╠→╵↓╚╗╠╗╵↓←╚╣╷═╚↑→╝╦═╗↓╶↑╣╷╔║║↓↑║╗═╠↑╵↑╗═╔╩→╶↑╔╣╔═→╵←═╩╷═╚↑15↑╠╔╣↑╝←╠╔══→╵↑╣╷╔║╝←↑╦═╝╔→╶6→╩╔╗╣↓↓╝╔╠╴╚→←══╚╦╴←2↓╩═╝╔→╶2→╩╔╗╩→→╩╷╝╔╝↑2↓╝╩╷╔╚→2→╗╩╗╝╶←2↓╚╦╴╚╗↓↓║╚╝╠╷→→═══╩╷→←╚╦╝╗←╶↑╦═╗╝╶←2→╦╣↑╚╝←═══╦↓╶↓╠╝╔╝↑╵↓║╩╗║↓╶2↓╩╴╚║╔→↑╦╴╚║║↑←╚╔═╩↑╴2→╦╴╝═╚↑5↑╠╔╗╩→←╔╝╩║↑╶→╝╣╷╚╗←↑║╣╷╔║↓←═╚╗╩╷←←══╔╠→╵↓║╝╔╠→╵←═╦╝╶═←↓╩╝║╗←╶→╗╚╩╷╗↓←═╚║╠╷→→╗╣╵╔║↓↓╚╗╣╝╶←↑╣╔╗║↓╶→╗║╝╠╷↓↓╣╝╶╔║↓→╗╚╣╔→╵↑╔╝╣╗←╶↑╠╔╝╔→╴←╦╝╶╔║↓←╠╷║║╚→→╣╷╚╗╚→7→╩╔╣↑╝↑╗╦╝╶╔↓↑╗╩╔═→╶←═╩╷╔╝←→╗╠══→╵↓╚╣╷╝═←←╚╗╠╷╝←↑║╗╔╣╵←←═╔╩╗↓╶←═╔╝╩↑╶→═╣╷╝═←2↓╚╣╷╝╔↓→╩╗╴╚╔→2→╦╗╚╩→←═╩╔═→╶←═╚╦╝↑╶↑╗═╚╣↑╶←╠╷╝╚╗←←╠╗╵╔║↓↓╝═╩╷╚↑↑╗═╩╷═←↑║╠╷══→←╚║╗╦╵←↓╚╗╚╩╷→2↑╔╣║╔→╵↑╦╴╚╗╚↑↓║║╩╝↑╶↓║║╠╴║↓→╗╣╝╶═←↑║╔═╣╷↓↓║║╣║↓╶↑╗╩╷╚║↑↓║╩╗╚→╶↓╝╔╩═→╶←╚╔╩║↑╴2→╦╗╵║╚→→╩╷═╝║↑↑╗╠╔╝↑╵→╗╩╝║↑╶←╠╷╝═╚↑↓╝╔╩╗↓╶↑╦╴╚╗╔↓↑╦╴╔║╚→→══╩╷╝↑←══╠╷║↓←═╔╩═→╶←╠║║╗╵←↓╠╗╵║╝←↑╗═╔╣╵←→╣╷╚═╗↓→═╗╣╵═←→╗╚╩╷═→→═╗╚╦→╵←╚╠║║↑╴→╝╦╴╚║↑→═╗╠╝↑╵↓╝╔╚╦╴↓→═╝╦╴═←←╚╔═╦╴↓↓║╝╠║↑╵←╠╷╝═╔↓→╗╩══→╶↓╝═╦╝╶←↓╣╝╶═╔↓↑║║╗╦╵←→══╝╠↑╴↑║╗╩╷╚↑→╦╴╝╔╝←←══╦╝╶←↓║╝═╠╷↓→══╝╦→╶↓╝╦╝╶═←←═╦╚═→╶←╔║╠╴╚→↑╗╩╷═╚↑→╩╷═╗╝←↓╚═╗╣↓╶↑║╣╷═╔↓↓╚╗╣╵╔↓↑╔╦╗╵║↓↑╠╔═╗╴↓←╚╗╔╣↓╶→╣╷╝╔╝←↑║╔╝╣↑╶↑╔═╦╴╚→→╦╝║║↑╵←╔╝═╠╷↓2→╦╗╚╣↓↑║╦╴╔╝←↑║╔═╦→╵←═╠╷╚╗↓↑╦╗╚╝↑╶→╩╷══╗↓↑╗╚╦═→╶↓║╝╠╷╝←↑╔╝╗╩↑╶→╗╚═╩╷→←╚╦╴╔╝←2↑║╣║║↑╶↓╠╴╚══→→╝╔╝╠╷→←╔║║╩╴←←═╔║╩╴←→══╩╗╴←→╝║╦═→╶↓║╚╣╷╝←←╔╝╔╠→╵↑╔═╝╣↑╶→══╩╔→╴"),
            new CodedMap("Green Cave", "↓║╬╴╝╔╠↓→╝╗╩╠╦→╴╶╶→╝╦╴═╩╠╷→╶↑╦═╝╣╠↑╴╶╶↑╔═╩╷╦╴╣↓╶←╠╷║╠═╩╷→╵↑╣║╗╩╠╷→╶╶→╩╷╦╴╝═╦↓╶←╔╩╴═╦╠╴↓╶↑╗╩╬↑╴╔╚↓║║╠╴╣╣╵╶←↓║╩╝╠╠╷→╴╶←╩║╔╩╷╣╷↓╶→╣╠╔╝╦→╴╵╶↓╚╣╷╚╦╴╣↓╶↓╝╦╣╚╦╴↓╶╶←╚╦╴╩╷═╩╷←↓╩╴═╠╦╴╵╔↓←╔╣╠╴╣╚→╶╶"),
            new CodedMap("Halls of Agony", "→╝╦╣║║║↑╵╶→╝╠╷╦╗╵╚╗↓←╔║╩╣╔╝↑╵╶→╬╷╗╚╩╝╔→←╦╝╦╠╚→╶←╚╠╗╴╠╷↓↓╠╗╚╩╝╠↑╴→╦╗╚╩╩╔→╴→═╗╩╝╔╩↑╴╶↓╩╴╠╷╝╚↑↑╔╗║╩╣╔→╵╶→╝╦╣╷║↓╶→╝╔╩╦→╴╶←╩╗╠╦╝↑╚╶↓║║╩╴══╦↓╶←╔╝╔╠╴╩╴═←↑╣╣╷══←╶↓╠╴║╣╝╔╠↓↑╣╗╠╔╩↑╴╚←╔╩╴╚╗╦╝╶←→═╣╗╵╩╗═←╶←╔╣╵╩╗←╶↑╔╬╷╗╚╩→↓╠╗╚╬═→╵↑║╣╷╔╣╵←↓╝╩╷╔║║╠╴↓→══╝╦╦╴╚→╶↓╝╦╩╗↓╶╶↑╔╩╣╷╴╚║╗←↓╣║╚╩║╔→╴╶2↑╔╦╩╔╣↑╝╵←╦╝╔╠╠╗╵↓↓╝╩╣╷╦╚←←═╩╠╔╦→╝╶↓╣╚╩╔╦→╝╶↑║║╠╷╣╷↓←╚╔╩╷╦╴↓↓║╩╴╩╷╔↓←╠╷╚╗╠╴↓↑║╔╬╷╗╚╣↓↓╣╩═╗╝╶╶═←←╠╷╝═╩↑╶↑║╦╴╠╷║↓→╗╣╝╦╩╶←←╦╝╔╬╵══←↑╣╔╦╗╚╩→╶→╝╣╦═→╶╶↓╩╝╠╷╗╚╝↑╶↑╔╩╔╦→╩╴→╝╦╩╷╝↑╶→╩╦╣╔╗╝↓╶←╦╩╴╔╩═←↑╠╷═╩╷═╗║↓↓╚╩╷╩╔╝║↑╴→═╩╠╷═→╴←╔╝╦╩╴╶←↑╔╗╚═╣╷╩╴←↑╔╝║╠╷╦╴║↓←╔╩╴═╠╔╝↑╵→╦╗╩╣╝╶←↑╠╔╝╣╷╴←↓╚═╝╠╣╷╴╚↑→═╦╴╝╦↓╶↓╝╦╩╴╶═←→╝╦╣╷╚╝║↑╶↓║╠╗╩╩→╶↓╝╦╝╔╬↓╶→╣╷╝╦╝╶←←╩╗╠║╗╠╵←↑╣╗╩╗╦╚←╶←╦╝╠╷╩╚↑→╣╷╝╦╝╔╠↓←═╦╝╠╷╩←↑╦╗╠╗╚╩→╶↓╚═╗╩╗╣↓╶╶→╗╠══╗╵╩→╶←╚╠╷╩╷╝↑"),
            new CodedMap("Ice Cave", "↑║║╣╠║↑╴╶↑║╦╴╔╣║↓╶↓╚╝╠╷╩╔→╴←╚║║╬╔→╴╶↑╠╠╔╝╔→╴╴↓╩╦╴║╝╶═←↓╝╬╷╚══→╶↓╚╣║╔╩↑╴╵"),
            new CodedMap("Keeps", "→╣╷╚═→←═══╚╔══→←╚╗══╚╗╚↑↓╝═╚╗╚╗╚↑→═╝║╗╔╝═←↓╝╠╗╵←↑╠╷═╗↓→╝╔╗╠╦→╚╝←╔╩╴╔↓↓╚╗╝╔╚╗╝←→═╩╷╝↑2↑║╦╝↑╶↑╔╣╷╚→↑║║║╔╗╚╝↑2→╗╣║↓╶←╚╦╴═←↑╠╔╗╩╗╚═→↓║╝╚╣╗╠↑╚↑╠╷╗╚→↓╚╣╷║↓2↑╣╗═←╶↑╠╗╴╚↑2↑║╗╠↑╵↑╣╗╦╚═╩╷←2↓╣║║↓╶↓╩═╗↓╶↑║╗══╔╚╗↓→╦╗╚╩╝╔═→2←╠╷╚═→↑╣╗╚↑╶↑╔═╗╝╔╚═→←╩╔═→╶↑╣╷╔║↓↓╝═════╚↑2←══╦↓╶→╦╝╗╵←↓║╚╦→╵→═╗╣↓╶↓╚╝║║╔╗╚→↑╔╩╷═→↑║║╗═╚║╗←↓║║║║╚═╝↑←═══╔╝╔╝←↓║╩╝↑╶↓║╝╔║║╝╚↑→═╝╔╝╔╝║↑→╦╣╗╚╝╚╔→↑║╗═╔╝╚║↑↑║╦╗↓╶↓╚╣╷╝←↓╣╚═→╶2↓╠╴╚═→↓╝═╔╝══╚↑↓║╚═╦╗╚╣↓↑╔╝╔╗║╝╔↓↑║╔╦╴↓→╩║║↑╴→╣╷╝╔↓↑╗╦╵═←→╝║╔═╗╚╝↑↑╗╦╵╔↓←═╚╠↑╴→═╝╗╚║╗═←←╠╷╚╗↓↓╣╩╝╔╝↑╔╚↓╝╚╗╚╗═╔↓→╣╗╵═←↑╗╚╔╝╔═╗↓←╔║║╚╝║╔→←═╦╵╚↑→╝╦═→╶↑╣║╔→╶2↓╚╗╝╔╚╗╚→←═╦╝╶←2→═╗╣╵←←╚║╔╝╔╗╚→2↑╦══→╶→╝║╗╦╝╦╚←↓║╚╝║╔╝║↑→═╣╗╵←←═╦╚→╶↑╗╩╗←╶2↑╦╗║↓╶↓║╚╩╷→←╚╗═╚╔╝╔→↑║╗╦╵←←╔║╝╔║║║↓↓╚═╝╣╦→╔╚→╗║║╣╝╦╚←2↑╗╚╣↑╶↑╔═╝╣╗╔╩←↑╔╦╴║↓→╝╔═╗║╚╗↓→╝║╔═╗║╚→↑╔═╗║╝╔╝←→╝╣║↑╶↑╔╝╦→╶↓║╩╗↓╶↓╝═╚║║║╗←↓╚═╝╣╣↑╔╚↑╠╔╩╔╣↑╝╴→╝╣╔→╶↓╚═╝╣╗╠↑╚↑╔╝║╔╝║╗←←═╩╗←╶←╚╗╔║╝╚╗←↓╝╔╝╚╗╔║↓→╩╷╝║↑↑╔╝╣↑╶→═╝╦→╶←══╩╷←↓║║╚╩╔╗╣↓↓║╣╵╚↑→╣╔╗↓╵↑╔╝║╔╝╗╚↑←╚╦╴╚↑→╗║╩→╶→╗╚╝╔═╗╝←↑║╔═╝╗╚╔→↓╝═╩╷←↑╦╝║↑╶←╚╔╩↑╴→╝║╗═╚╔═→→╩╔╗╣║║╝←←╚╗╔╝╔╚╗↓→╗╩╝↑╶←╔╩═→╶2↑╗═╦↓╶↑╔╣╷║↓←══╚╗╚╗╚↑↑║╔╝║╗╔╝←↑╗╠╷╝←2↑╠╷╗║↓↑╗╔╝╔╚╗╝←↓║╚╣╷↓→╗║╣↓╶→╣║╗╵←↑║╔╩↑╴↑╔╣╗╵←←╚╗══╚╔═→↓╣╝╔╠╚╗╚→↓║║╚═╝║╔→←╔╣║↓╶2←══╦╵←→╦╣╗╚╝══←↑╣║╗←╶←╚╗╔║║╝═←↑╣╦═╝║↑╔╚←╚╣║↑╶←═╔╚╗╝╔╚→→╗╝╔╚╗╝═←←═╠╔→╵→╦╴╝╔↓↑╔╣╔→╵←╩╗╠╔═╝↑╚↑╣╔═→╶←╚╣╷╚↑→╝║╦→╶↓║╣║↓╶←╩╗╔╩╔╝═←↑╗╚╗╚╗═╚↑↑║╠╔→╴↓║╚╗║╝╚╗←→═╩╔→╴←╩║║↑╶←═╔╝╚╗╔║↓↓╣║╣╝╶╔╠↓↑╗═╩╷←↑╔═╗╚╝╔═→→╦╝║↑╵←╩╷╚║↑→╦╦╗╚╝╚╗↓→╝╔╝╔═══→→╩╔╗╩══╝↑↑╔══╝╗╚╔→↓╝╚╗╔║╚╗↓↑╔╝║╗╚║║↑↑╔╝║╔═╝║↑←╦╝╦╚═══←→╝╔╩╷→→═╣║↑╵↓║╣╚→╶→╗╣╝╶←→╗║╣╵←↓╝╚║║╗╔║↓→╗╚═╩╦╗╝←←╚╔╝╔╝║║↑↑╔╦╗╵↓↓╚╩╷╗↓↑╠╔╗╣╚═╗↓→╝║║╗╔║╝←→╩╔╣╗╝══←→╝╠╷╗↓↑║╔╝╔╗║║↓↓╚╝╔╝╔╝╔→↑║╗══╚╔╝↑↓╠╗╚╩═╝╔→→╝╔╝╗═╔╝←→╝╔╝╗╚╗╚↑←╚╗╩↑╶←╚╔═╝╗╚║↑←═╔╝╦╝╠↑╚↑╣╦╗║║↓╔╚↓╠╦═╝╗╚╝←→╝╔╗║║║╚→←╔╝╩↑╶↓╚╗╚╗╚╝║↑↑╔╝╠╷→↓╝╠╷║↓↓╝═╩↑╶"),
            new CodedMap("Pest Tunnel", "↑╔═╝║╔╦╦╗╵╵↓→═╗╠╗╵╚╩╷═╝↑←╩║╗╩↑╶╶←╦╵╔╝═╔╝╠╷║↓←╦╬╴╵╠↑╚↓╠╴╩╴╚║↑→╣╦╴╵╚║↑↓╣╣╵╠↑╠╵→╝║╣╷══╩╷╚╗←→╗║╩╴═╩╷══╚↑←╠║╦╴╵╔↓→╝╠╷═╝╔╝╠╷╝↑←═╔╣╩═╗╚═→╶╶←╩╦→╦╠╵╶↓╝╔╝╚║╦╴╦╝╶←←╦╬╴↓╦╚╶←╩╷═╚╔╝╦╴══←→╗╣╠╝║║║╗╵←╶←╠╷╚╗╣╚╝║║↑╶↓╠╴╠╴╚═→←═╠╔╩╷→╵↓╠╴╝╩╷╚↑↓╩╝╠╗╴←╶→╝╠╷╣╷╚→→╝║╦══╗║╠→╵╶→╝║╦╝╠╔══→╴╶↓║╚╩╠╷→╴→══╗╝╦╚═╦╴↓╶→╗╠═╗╵║╣╝╶╔↓↑╠╬↑╗╩╴╶←═╩╷╚╣↑╶↓╚╝║║╠╷╝╠╷╗↓→╬╷╣↑╚╣╵↑║╔╩╷╝║╔╣║↑╵↓╣╣↓╔╬╵╶↑╗╦╵═══╩╷╔╝←←╬╷╩→╔╠╵↓╝╔╝╩╷╔╚╦═→╵↑╗╚╦╴╦↓╶↓╩╩╷═╝↑╶↓╚═╣╷╠╴↓↓╬╬╷→╚╝╶2→═╩╗╴╚╔╩╷══→2↑╗╩╔╩╷→╶←╩╗═╦↓╶╶↓╩╩╷══→╶←╩╗╚╠╷→╶↑╣╗╩╷═←╶↑║╣╷╠╷║↓↓║║╝╚╣╣╗╚↑╶╶↓╚╗║╚═╦╴╠╴╚→↓╝══╠╷╣║║╝╶←←╠╷╝╩╷╚↑←╚╦╴╚╗╦║╝╶═←↓║╚╗╚╦╴╩═╗↓╶←╠╷║╠╴╚→←═╠╷╩╗╚═╗╚→╶↑║╗╔╝╠╷╣║╚→╶→═╝╔╝╦╝╦╴╚↑╶→╩╷══╝╠╷═╝║↑→╗╝╔╝╦╣║╚→╶╶↑╗╩╷╠╷║↓↑╔╣╷║╩→╶←╠╷║╝╩↑╶←╦╚╗╚╝║║╣╷←╶←╩╬╷╴╦╚←↑╣╷╔║╣╵←↑║║╗╔╣╵╚╣╷╔↓↓╝═╔╝═╔╣╠→╵╶→╩╔╬╷╴╩→↑╗╩║╣╷←╶↓╝═╠╷╠→╵→╝║╔╝╣║╔╣╷↓╶↑╔╣╗╵╩↑╶↓╠╣╷╩╩→╶→═╗╚╝╔╝╣╠↑╴╶→╝╣╔╗║║║╣↓╶╶→╬╔╣↑╣╵╵←╔╣╠╝↑╵╶←╠╷╝╚╣╷╚║║║↑←═╚╠╦╴╴←↑║╗╦╵╠║╔╝║↑╵↓╩╣║╗╵←╶↓╝╩╷═╔╠╴╚╗╚→←═╚╠╷╝║║╣╷╚↑↓╠╦╴╚╬╴↓↑╠╷╝╔╗╚╝║╣↑╶↓╩╩╷╗╝╶←↓╠╴║║╝╩╷╔║╝←←══╚╠╗╴╚╦╴╔↓→╩╦╗╬╴╵←↑╬╦╴╴╠↑╚→╗╩╣╔→╵╶←╔╠╴╚╗║║╚╩╷→↑╣╣╷╦╩╶←↑╔╦╦═→╵╵→╗╝═══╦╩╗↓╶╶↓╣╝╦╬↓╶╶→╦╦╴╩╣╵←↓╝═╠╷╣╝╶╔║║↓→╩╷═╗╣║╚╗║↓╶↑╗═╚║╗╔╣╵╠╷↓→╦╣╷╚╬╴↓↓╣╝╶╔╝╠╷╚╗║↓→╩╗╴╩╗←╶←╔╝╚║║╦╴╦║↓╶←╠╷╝╚╣↑╶←╚║╗╚╦╴╩╔═→╶→═╝╣╦→╶╶←╦╵╚║║║║╗╦↓╶↑║╠║╔╝╣║╔→╴╶←╠╷║║║╝╩╷╔║↓←╩╦╴╠╷╩←←╦╣╵╦╠╵←↑╬╦→╴╔╩╶←╔║╚╦╴║╠╗╵║↓"),
            new CodedMap("Sewers", "↑╦╴╩╷╚║╣╷╠╷╣╵╔╝═╚╠↑╴↓╚╦╩╷╩║╔╦╝╦╝╠╔→╴╴╵╵╶→╦╝╠╗╴╵══╩╦╴═╩╦═→╶╶╶→╦╗╚╩═╗║╝╩╗╦╚←↓╣╝╔╩═╔╚╗╣╝╦╚←→╩╦╗╣║║║╝╶╔║║╚╦╦╴╩╣╵←↓╣╩╝╔╗╚╩╔╗╩→╔╚→╗║║║║║║║║╝╔╝╩╷═╠╷║╝╔╣╣╩╴╶╶╔╩╴═←↑╔╝╔╩╣╣╷╴═╦╵╚║╠╠╷→╴╶↑╣╷╠╷║║╣║╣║╣╵╶╶╠╷║║╝╔╝╔║║║╝╔╝╔╚→→═╝║║╔═╝╔╝║╔╝╣╣╔╣╣╣║╠╷══╝╗╵←╶╶╶╶→╩╔╣╔╝╔╗╝╠╗╚╣↓←═╩╣╷╩╷╩╗╚╦╴╚╔═╩╷→╶╶↓╣╝╠║╗╚╔╝╩╗╠↑╚←╚╦╴═╚║╣╠╠║╣╷╴╴═╦╵←╶→╩╔╣║╔══╦╗╝╚╩→←╩╦══╝╔╝║╔╗╠╣╷╚╣↓╠╷╠╵→╩╔╦╗╝╚╗╝╦╩→╔╚↓╣╝╦╚╚║╔═╩╔╣↑╝←╚╠╗╴═╚╦══╣╣╷╵╩╷╩╷←╶↑╣╗╠║║╔╗╠╦→╚╝╚↑╔╣╷║╩╦══╝╦╩╷╦╗╵↓╵╶╶↓║╚╩╷╝╠╷╦╣╷╵║╣║╣╚→╶╶→╣╷╚╗╣╵╦║╩╗╝╶╶╦╵═╩↑╶↑╠╔╦╝╗╝╚╗╦╝╔╩←↑╠╷╝║╣╷╩╗═╩╦╝╠╷╗↓╶╶╶↑╠╦╣║╔══╝║║╗╩╴╩╣╷╠↑╚╶↑╔╝║╔╝╔╝║║║╔╗║║║║╠╴╝╠╷╩╴╠╷╣╣╚→╶╶↓╝╚╣╷╦║╠╴╩╴╶╚║╗╦╵╩↑╶↓╠╩╷══╗╵╩╣╷╝╶╔╚╦╴╣↓╶2←╔║║║║║║║║╝═╔╝╔╩╴╩╷╩╷╩╷╔╣║╝╶╠╷╝←→═╣╔╣╦╩╷╩╔══╣║↑╴╵╵╵╶→╣╷╩═╦╴╣╵╶╔║╚╗╩═╦╴↓╶→╦╣╗╚╝╚╔╝╣╗╔╩←↑╔╩╦═╝╠╷══╝╣╠╦═╝║╔╝╔╝╔╝║║╗╴╴←╶╶╶↓║╩╴╔╣╚╦╦╴╵╚═╗╠╴╣╵╶←↑║║║╗╦╝╶╔╩╴╠╣╣╦→╵╶╶╶↓║╝╩╷╠╷╩╴═╔╩╦══╩╷→╵╶↑╣╣╔═╝╔╦╣↑╚╝╔╚←╠╠╷═╝╣╣╷╵╩╗═╚╔╩↑╴╶╶↓╣╝╔╠╚═╝╔╦╗╠╝↓↑║╔╝╔╝╔═╝╔════╩╣╣╦╦══╣║╔╗╴↓╵╵╶╶╶↓╣╩╴╔╩╔╝═╔╝╔╝╚╣╦╴╠╷╠↓↑╗╔╝══╔╝══╔║╚═╩╦══╩╷╩╷═╣║╠╷╝↑╴╵╶←═╩╔╩╦╴╴═╦╵╩╔══╩↑╴╶╶↑╗═╚╣╣╠╔═╣╣╷╴╵═╩↑╶╶╶↓╣╵═╦╵═╠╦╝╣╗╵═╦╵╔↓╶╶↓╠╴╣╝╶═╔╣╝╶╔╠╴╣╵═╦╵╚╔╝║╔╝║║╔══╝↑←╦╣║╝╶╶╦║╣╵╶╔╣║╝╶╦╵╔╝══════════←←╦╝╔╩╔╝╔║╠╗╚╣↓←╦╝╔╩╔╝╚║╠╔╦→╝←╦╩╴╦╠║╝╶════╔║╣╣↓╔╠╵↑╠╔╗╣║║║╝╩╗╔╠↓↑╣╷╠╷╣╣╵╶═╚║╣╷╚╣║║↑╶→╝╦╴═╩╦╴═╠╗╵╔╣╵╠╗╵←╶←╩╷╔║╣╵═╩╷╦╩╴╶══╔╣╵═══╔╝╔╝═══╔╚→↑╠╔╗╩══╗╝╦╣↓╔╚↓╩╴═╦╝╶═╠╷╠═╗╵╠╴╝╩╷←↓╣╣╚══╝╠╠↑╗╝╔╚←╩╗╦╚═╚╗═╦╝╔╩←↓╚╗╩═══╣╷╣╵╶╦╵╦║╠→╵╶→╦╣╷╩╣╵══╔╝╔╝══╩╗╠╷╠↓→╗╝═╔║╝╔║╝╔╝╔╝══╦╠╴║╣╵╶╠╷╝╠╷╩╴╚↑↑╠╗╴╦╵╦╣║╠╴║║║╠╴╚→╶╶↓╠╗╵╠╴╣╚╣╔═╗╠╴╵║╠→╵╶→╩╦╣╷╣║╝╶═══╔╝╚╣╗╦╠╵←→═╩╷╦╴╩══╩╷╦╴╠══╗╵↓╶←╠╗╵╩║║╠╷╝║╦╦═╦╴╵↓╶╶↑╔╦╴╚═╦╴╚╗╩╩╷╣╷╩╴╶═←↑╠╣╣╷╴╩║║╣╷╔╣╝╶╔║↓╶╶←╠╣╔╣║╗╵╵╠╣╗╵╚║╣╷←╶╶↓╝╦╵╚╗╦╵╠╗╵╩╦╝╗╩↑╶╶╶←╦╝╔╩╚╗╚╔╩╔╣↑╝↑╗╔║╩╴╩║╗╠╣╷╵╔╣╵╩↑╶╶↓╣╣╚╗╚═╦╦→╚╝╔╚↑║╠╠╠╷══╣║╦╴╴╴╵╚╗╦╵←↓╚╝╔╩╦╩╷╝║╦╴╴═╩╦→╶╶╶←╚║╔═══╝╔═══╝╦══╦═╩╷╦╩║╔═╩↑╴╴╵╵╶→╦╗╚╣╝╔║╚╩╔╣↑╝←╔╣╣║╠╗╵╠╗╵╚╩║╠╷→╴╶╶←╔║║║║╝╔║║║║╚══╣╦╝╦╝╠╷╩╷═╩╗╴╵←╶╶↑╠╦╗╝╔╝╔╝╦╝╠↑╚↑╠╔╦╝╗╝╚║╣╣↑╔╚↑╗╠╠╷═╩╷╩╷══╝╠║╣↑╴╵╶↑╣╷╩╷═╩╷╚╗╩║╣╷╠╗╵╚↑╶↑╣╦╴╔╠╝╔║║╝══╚╠╦╦╴╩╴←↓╚╣╔╩╣╣╔═╝╔╩╷╩╔╝╔╝╔╝║║║║╔╝↑╴╴╵╶╶→═╝║║║╔╝║║║║║╔═╩╦╝╦═╦═╩║╦→╴╴╵╶╶╶↑╦╴╔╝╚╗╦╣╠╴╠╴╩╴╶╶╔╚→←╠╷║╝╩╷═╦╠╴╠╴╠╴╝╶╚║↑→╗╣╠╴╠╴║╝╶╩╷╩║╗═╩╷←╶→════╝╔╝╔╝╔╝╔╝║╣╦╦╝╔╩╷╝╠╷╦╝↑╵╵╶╶↓╝╩╷╠╷╩╴╠╷╚╗╠╗╵╚╣╷║↓↑╣╣║║║╔╩╔╦→╝╔╚↓╝═╠╷╝╔╚═╣╷╣╩╣╷╠→╵╶╶→╗║╠╴╠╴║║║╣╵╠╣╷╵╩╷╔↓←╦╝╔╩═╚║╗╦╝╠↑╚↓║║╝══╔╝══╔╝╔╣╝╶═╔╝╩╷╠╷╣╵╦╣║╚→╶╶→═╝╣╦═╣╦╝╔═╩╷╦══╝║║║║╔╝║║║↑╵╵╶╶╶"),
            new CodedMap("Sewers (water)", "↑╦╴╩╷╚║╣╷╠╷╣╵╔╝═╚╠↑╴→╦╗╚╩═╗║╝╩╗╦╚←↓╣╩╝╔╗╚╩╔╗╩→╔╚→╗║║║║║║║║╝╔╝╩╷═╠╷║╝╔╣╣╩╴╶╶╔╩╴═←↑╔╝╔╩╣╣╷╴═╦╵╚║╠╠╷→╴╶→╩╔╣╔╝╔╗╝╠╗╚╣↓←═╩╣╷╩╷╩╗╚╦╴╚╔═╩╷→╶╶↓╣╝╠║╗╚╔╝╩╗╠↑╚←╚╦╴═╚║╣╠╠║╣╷╴╴═╦╵←╶→╩╔╦╗╝╚╗╝╦╩→╔╚↓╣╝╦╚╚║╔═╩╔╣↑╝↑╔╣╷║╩╦══╝╦╩╷╦╗╵↓╵╶╶↓║╚╩╷╝╠╷╦╣╷╵║╣║╣╚→╶╶↑╠╔╦╝╗╝╚╗╦╝╔╩←↑╠╦╣║╔══╝║║╗╩╴╩╣╷╠↑╚╶↓╝╚╣╷╦║╠╴╩╴╶╚║╗╦╵╩↑╶→╣╷╩═╦╴╣╵╶╔║╚╗╩═╦╴↓╶→╦╣╗╚╝╚╔╝╣╗╔╩←↑╔╩╦═╝╠╷══╝╣╠╦═╝║╔╝╔╝╔╝║║╗╴╴←╶╶╶↑╣╣╔═╝╔╦╣↑╚╝╔╚↓╣╝╔╠╚═╝╔╦╗╠╝↓↓╣╵═╦╵═╠╦╝╣╗╵═╦╵╔↓╶╶←╦╝╔╩╔╝╔║╠╗╚╣↓↑╣╷╠╷╣╣╵╶═╚║╣╷╚╣║║↑╶←╩╷╔║╣╵═╩╷╦╩╴╶══╔╣╵═══╔╝╔╝═══╔╚→↓╩╴═╦╝╶═╠╷╠═╗╵╠╴╝╩╷←←╩╗╦╚═╚╗═╦╝╔╩←↑╠╗╴╦╵╦╣║╠╴║║║╠╴╚→╶╶↓╠╗╵╠╴╣╚╣╔═╗╠╴╵║╠→╵╶→╩╦╣╷╣║╝╶═══╔╝╚╣╗╦╠╵←↑╔╦╴╚═╦╴╚╗╩╩╷╣╷╩╴╶═←↑╠╣╣╷╴╩║║╣╷╔╣╝╶╔║↓╶╶↓╣╣╚╗╚═╦╦→╚╝╔╚↑║╠╠╠╷══╣║╦╴╴╴╵╚╗╦╵←→╦╗╚╣╝╔║╚╩╔╣↑╝←╔╣╣║╠╗╵╠╗╵╚╩║╠╷→╴╶╶←╔║║║║╝╔║║║║╚══╣╦╝╦╝╠╷╩╷═╩╗╴╵←╶╶↑╠╦╗╝╔╝╔╝╦╝╠↑╚↑╣╷╩╷═╩╷╚╗╩║╣╷╠╗╵╚↑╶↓╚╣╔╩╣╣╔═╝╔╩╷╩╔╝╔╝╔╝║║║║╔╝↑╴╴╵╶╶→═╝║║║╔╝║║║║║╔═╩╦╝╦═╦═╩║╦→╴╴╵╶╶╶↑╦╴╔╝╚╗╦╣╠╴╠╴╩╴╶╶╔╚→↓╝╩╷╠╷╩╴╠╷╚╗╠╗╵╚╣╷║↓→╗║╠╴╠╴║║║╣╵╠╣╷╵╩╷╔↓←╦╝╔╩═╚║╗╦╝╠↑╚→═╝╣╦═╣╦╝╔═╩╷╦══╝║║║║╔╝║║║↑╵╵╶╶╶"),
            new CodedMap("Shocktowers", "→╗║╝╔↓↑╗╔║╚→↑╗═╚╠↑╴→╦╗╵╚╝↑2→╣╷╝═←→╩╗╴╚↑→╗╚╦╗╵↓↓╚╝╔╩╷→↑╗╚╠╷═→↓╠╝╔→╵←╚╔╝║↑→╝╦╗↓╶↓║╚╩║↑╴→═╗╣╵←↑╔╗╚╦╴↓←╠╷╚╗↓↑╠╗╴╔↓→╣╷╝╔║↓↑╔╩║╗╴←↓╩╴╚╗╔↓↓╚╦╴╚→←╔╩╴╔↓→══╝╔→↑║╔╗║↓↑╔═╝╔→↑╣╗═←╶→═╦╴║╝←3→═╝╗╚↑3→╝╔╦╴╚→←╚╗╩╷←2↓╣║╚→╶↑╠╷╝║↑→╝║╣↑╶←════←2→╦╴╝═←2↓╩╴══←←╦╵═╔↓↓║╩╴╚↑↑╔╗║║↓↓║╝╩╷←↓╝╔╣╝╶←→╩╷═╗╝←↑╔╝╠↑╴↓╚╣╷╚→↑╗╚╔═→↑║╔╝╠╷→↑╣╷╚║↑↓╣║║↓╶↓║╚╝╠╷→2↑║╣╷╚↑←╔║║╚→→╗╝╦↓╶←╦╵══←↓╝╚║╗←→╣╔╗↓╵↑║╗╚╔→↓╝══╔↓2→╗╝╔║↓↑║╗╩↑╶↑╔╣╗╵←←╠╔╝↑╵←╚╔═╗↓←╦╵╔╝╚↑↑║║╣╷←→╗╝╔╝←→╦╴║╝←↑║║╣↑╶↓╣╝╶═╔↓↑║╗╦╝╶←←╔╚═╩↑╴→╝╗╚╣╷←←╚╠╔→╴←═╔╩╴═←↓╚╝╠╷╗↓↓╝╔╣╵←↑╔╩║║↑╴↓╝╩║↑╶→╣╷╝══←↑╔═╣↑╵↑╦╗╚→╶→╝║╠╷→↓╚╝╔╦→╵2↑║╠╔→╴→╣║╔→╵2↑╣╷═╔╝←2↓╝╦╵╔↓2↑║╗═╔↓2←╔╚═╗↓2→╗╚══→↑╠╷═╗╚→2←═╚║║↑←╚╗═╚↑→═╣╷║╚→↓║╠╴╝╔↓←╚╔═╝↑↑╦══→╶←╚╔╝╗←→╝╔╩╔→╴2→╝╗═╔↓↑║╗╠╗╵←→╩╷╝║↑←═╔║╝←2←╔╠╗╵↓2→╣╷╚═→→╗║╝═←↑║╔═╦╴↓→╝╗══←→╝║║║↑2→╦╗╵║↓2↑║╗╔║↓↓╚╣╔╗↓╵←╔║║║↓→╝╦╴╚↑2←══╚╗←←═╚╠╷→→╗║╚╝↑←═╚╠↑╴→═╗║╝←↓╩═╝↑╶←═╚╠╗╴←→╗╚╦╴╝←↓╚╩╷╝↑↑╗╔╝╚↑←╔╚══→→╝╔╦╴↓←═╔╚═→←══╔║↓←╔║╝╠╷↓←═╔╩╴←↑╗╔╝═←←═╔║╚→←╠╷╝╚╗←←╠╗╵═←←═╦║╝╶←→═╝╗═←↓║╠╝╔→╵←╚║╣↑╶←╚╦╴═←↓║╚╣╷↓→╝╗╚╗←→╣╷║╝←↓╚╗╝╔↓←╔╚═╝↑←╔╚╗║↓3↑╦╗║↓╶←══╠↑╵↓║║╝═←→╝╔╣↑╵↑╣╷╔║↓→╝╠╷╝↑→╗║╚═→→╗║║╚→2↓╚═╩↑╴←╚╠╷╝↑←╚╦╴╚╗←↓╝═╚╗←↑╣╷╔╝╔↓↓║╚╝╠↑╴↓║╚═╦→╵↓╚╝╠╷→←═╦╵══←↓╩╴═══←↑║╔╣╷↓2↑║╗╦↓╶→╗╚╝║↑→╝╠╷═→←╦╝╶══←←═╚╗═←2→═╗╣↓╶←╔╝╦╵╔↓↑╣╔╝↑╶↓╝╩╷╚↑↓║╠╗╵↓→╗╠╗╵╚→↓╣╵╔║↓↓╝╔╚═→←╔╠╴╚→↓╚╣╷║↓↑║╔╦→╵↓║╚╗╚→→═╝╔╝↑→╣╷╝╔↓→═╝║╔→←╩╷══←↑║╗╠║↑╵↓╚═╝╔→→╗║╣↓╶↑╗╔║╝←↑╗╚╦╴═←→╩║╗╴←↓╝╚╗╔↓↓╚══╗↓←╚╗╚╗←↓╚╩╔→╴↓╝╔╝╔↓←╔║╝═←←╔╝╦╵←←╔╚╗╠→╵↑║╔═╗↓←╔╝╚╗←→╗╠╴║↓↑╔═╗║↓↑╦╴══←←╚║╔╗↓←═╔╩→╶↑╣╷═╔↓←╚╗╦↓╶↑╗╠╷╝←↓║║╚═→→═══╦→╵←╠╔═→╵←═╔╝╔↓←╚╦╴╔║↓←╩╗═←╶←═╠╷╚→→╗║║╩→╶←╦╵╚║↑"),
            new CodedMap("Shrouded Moors", "←╚╠╷══→↑╦╴╚╔═→↑╔╝║╠╷→3↓╠╦→╚╝→╦╗╵║║↓2→╦╣↑╚╝4↑╠╔╣↑╝→╦╴╚╗╝←↓╚═╣╷╝←→╝╠╷╗║↓→╩╔╦→╝←╦╵╔║║↓2→╩╔╗╩→→╦╗╵║╚→6↓╠╗╚╣↓6→╩╔╣↑╝↑║╗═╩↑╶2→╦╦→╚╝2↓╠╣↑╚╝4↓╠╗╚╩→4→╩╔╗╣↓←╚║║╠╷→←═╚╣╷╔↓↑╔╝╔╣↑╵↓╣║║╝╶←2↑╠╔╗╣↓←╚╗╔╣╵←←══╔╩╴←↑╗══╦╵←←╔╣╵╚╗←→╝╔╣╔→╵↑╠╷╝║╔→↓╣║╚═→╶→╩╷╗║║↓↓╝═╔╣╵←→╦╗╚╩→→╗║╚╩╷→↓╣╝╶═╔↓→╗║╝╦╵←→╗╚╗╣╵←↓╚═╩╷╝↑→╝║╣╷╔↓←╔║╝╩↑╶↑╔╦╗╵║↓↓╝╔╝╩╷←→╗╣╚╝↑╶→╗║╣║↓╶↓╚╗║╩╴←→╝╠╷╝╔→↑║╠╔╝↑╴↓╩═╗╚→╶↓╚╗╠╴║↓↓╝══╩↑╶↑╗╩╔╝↑╶↑╣╷═╔╚→←╚╔╝╦→╶↓╣╵═╚╔→2←╠╷╝╚╗←2↑╠╔╦→╝↓╚═╝╦→╶↑╣╗═╚↑╶↓╩═╝╔→╶←╩║║╔→╶←╚╗╚╣╷←2→╦╗╚╣↓→╦╴╚╗╚→→╗╝═╠╷↓↑╔╗║╠→╵↑╔══╩↑╴→╝╠╷═╗↓↓╝╦╝╶╔↓→╦╝║╔→╵"),
            new CodedMap("Spaghetti", "19←═╬╷╵←32↑║╬↑╴╶12→═╬╷╴↓45↓║╬╴↓╶6↓║╬╴╵←31←═╬╷↓╶10↓║╬→╵╶20↑║╬╷→╶7←═╬↑╵╶4→═╬↑╴╵17→═╬╷→╵18↑║╬╷╴←"),
            new CodedMap("Spider Cavern", "3↑║╬╷═→╶←═╬║↑╵╶4←═╬╷║↓╶2↑║╬╷╴═←2→═╬╷═→╵↓║╬╴║↓╶↓║╬═→╵╶2↓║╬╴╵═←2←═╬╷╵═←→═╬║↑╴╵"),
            new CodedMap("Spikey Cave", "→╣╠╣╷╴╵╔╝←↑╔╦╣↑╚╣╵↑╣╣║║╣↑╶╶╶←═╬↑╝╠╷╚→╗╠╦╴╚╩→→╣╣║╦╝↑╵╶╶2←═╬╗╵╔╩←↑╔╦╗╠╩→╵←╩╷╦╵╦╝╶═←↑║╠╠╗╴╴╦↓╶→╝╣╗╦╩╶←↑╦╩╷╩╷╝║↑╶↓╝╬╷╝╔╩←←╠╷║╝╩╷╠↑╵"),
            new CodedMap("Spire", "4↓║╠→╵↑╦╝↑╶↑╗╩╷←←╠╔→╵3→╩╷╗↓←═╠╷╝╔╚═→↓╝╚╣╗═╚↑╶↓╩═→╶←╔╣╵←4←╠╷╚→↑╦═╝╗═╚↑╶3↓╝╩↑╶←╔╚═╗╣╵═←2↑╦═→╶↓╩╴═══╚╔→↑╗╔╣╝╔╩←←╦║↓╶2↓╣╚→╶↓╠╴║↓2→╗╚╬╔╗╝↓3↑╦╴═←2↑╠╷╝↑↓╚═╗╣║╚→╶↑╗╔╣╝╔╠↓←═╔║╩╝╔→╶↓╝═╦╝╠↑╚→╗╩→╶↓╠╝↑╵3↓╩╗↓╶→═╝╦╴═══←→══╝╗╚╣↑╶2↑║╔╬╔╗╝↓←╚╗╩╗╔╩←→╗╝═╚║╦→╶3←╠╷║↓3→═╦→╵2←═╚╣╗╔╩←↓╚╗╠╣↑╚╝2↓╣╵╚↑↑╔╝╠╔╗╣↓←╚║╗═╠║↑╵2←╚║╗╠╷║╝←←╦╚╗║╚╗↓╶2←═╦╵←2→╝╣╷←2→╗╠→╵→╝╔═╗║╩→╶2↑╔╦→╵↑║╠║║╔╝↑╴→╗╣↓╶2←╠╗╵←2←═╩↑╶↓║╝╦╝╦╚←5↑╗╦↓╶←╚╔╝║╗╦╵←→╦╴║↓↑║║╣╗╔╩←2↑╔╩╷→↓╚╝║╦╗║↓╶↑╗╔╝═╔╠→╵4↓╠╗╵↓↓║║╚╝╔╣↑╵↑║╔╝╗═╠↑╵↓╝╦╝╶═╚╗←2←╚╣╷←←═╩╗═══←╶↓╝╚╗╚╗╩↑╶↓╝╩╷←5↑╔╦╴↓→═╝╣╗╦╚←2→══╩╦╗╝←2→═╗╠╴║╚╝↑4→╗╣╵←2↓╚╗╝═╩╗←╶2↓╚╗║╠╴║╚→2→╣╷║↓2←╚╔╩╦╗╝←↑╗╚╠╔╦→╝2←╦╵═←2↓╣║↓╶2↑╠║↑╴→╦╗╵↓↑╠╗╴╚╗╔║↓←═╔║║╣╵╔↓←═╚╣╗╠↑╚→═╩╷═╝╗╚↑←══╚╦╴╚╔→↓╚═╗╩╝║↑╶→╗╚╗╝═╦↓╶←╩╷╔↓↑╗╔╝╠╗╵╚↑←╦╵╔↓→══╦╴╝═╔↓→╗╚╦╦→╚╝2←╔╠→╵↑║╦╴══╚║↑↓╝╠╷╝╚║╗←↓║╚╗╣╵╔║↓←╚╗╔╣╵═╔↓↑║╗═╦║╚→╶↑╔╩↑╴→╣╷║║║║║↓→╝╦→╶←╠╗╵╔╝╚╗←3→╣╔→╵2↓╚╦→╵←═╔╠╴╝╔╚→↑╦╴╔↓↑╔╣╷↓↓║║║╚═╦→╵←╔║╩╴╚║╗←2→═╩↑╴↑╗══╔╩╗↓╶←╚║╣╷╔║║↓2→╣╷╝←2←╔╣↓╶→╗╚╩╔╗╩→←╦╝╶←←═╚╠╔╗╩→←╔╝╦╵╚╔╝↑→╗╝╦╝╠↑╚2→╝║║╗╔╣↓╶↑╗╩↑╶→╗╚═╗╚╩╷→↓╠═╗╵╝╔║↓→╗╝╦╝╦╚←↑╣╷╔↓←═╚╗══╩↑╶→╦╴╝╔╝╚╗←2←═╦↓╶↓╚╝╠╔╗╣↓←╚╗╦╝╦╚←←╚╣↑╶↓╚╝║║╔╦╴↓←═╚╗══╦↓╶↓║╚╦╦→╚╝←══╚╦╴╔╝←2↓╠╴╝←↓╚╣╷╝═╚║↑2↓╝╠╷↓←╩╔→╶↑╣╔══╝║↑╶→╩╷═→←╠╷╝╔║║╝←↓║║╩═╗╚→╶←╚╦→╶↓╩═╝╔╗╚→╶→╝╔╦╣↑╚╝2↑╣╔→╶←╚╠╔╝║╔→╴←╚║╠╷╝╔╝↑↑║║╠╔╗╩→↑╣╷═←↓╚═╦╗╠╝↓2←╚╠╷→↑╔╣↑╵↓║╣╵═╔║║↓←╠║║║║╔→╵↓╩╴═←2→╝╠↑╴↑║╗╩╗╔╠↓↑╗═╠╷║╝═←2↑╗╠↑╵↓╚╗╚╗║╣╵←←╚║╣╦→╔╚←╚╦╴←←╚║╠╔╗╩→←╚╔╩╠↑╗╝↑╣║↑╶←═╩╷╚╗╔╝←↓╝╔║║╝╦↓╶←╦╵═╔╝╚╗←2←╩║↑╶↓║╚═╗╝╦↓╶↓╚╗╣╝╦╚←2→═╩╷→→╝╔╦╦→╚╝↓║╠╴↓2←╚║╠╦╗╝←↑║║║║╠║↑╴→═╗╠╗╠╝↓↑╗═╩╣↑╔╚←╔╩→╶↑║╔╦╗╠╝↓↑╗═╚╗╦╝╶←←╔║╠╗╩╝←↑║╠╷→←╠║↑╵↑╗╦╵←3↓║╣╵←←╔╩╴←←═╠↑╵←╩╷╚║╔═╝↑←╦╝╶╔║╚╗↓↑╦╗↓╶→╝║╗╚║╠╷→→╣╗╵←↑╗╔╣╝╦╚←↑╔╗╠╦→╚╝↑║╠↑╴↓╝╔╚═╝╠↑╴↑╗═╚╔═╩╷→↑╗╚╬╔╗╝←→╗╠╴↓←╔╣╚══╗↓╶→╝╗╩╗╠↑╚→╝╗╚╗╦╵╔↓←╔╚═╩╔═→╴↓╚╗╠╗╩╝←←╩╷═←→╦╝↑╵↓╝╩╷╚╗╔║↓←═╔║╝╩╷═←←╚╔╩╔╗╩→→╩║↑╴←═╚╗╦╝╶═←↓╚═╝╔═╣↑╵↑║╠╷╝╔╗╚→↓╚═╝╗╚╠↑╴→╩╔→╴←╩╷╚↑↓╝╦╵←→╝║╔╦╗╵║↓2↓╝╔╣╝╠↑╚2↑╣╗←╶→═╦╴↓→═╗╚╝║╣↑╶↑║╣↑╶→═╝╠╔╦→╝↓╚═╝║╗╦╵←↓╝╦↓╶↑╗═╠║║║↑╵↑╠╗╴←←╔╝╬↑╝╔╚↓╝╔╣╝╔╩←"),
            new CodedMap("Westmarch", "→╩╷╝╔╝↑↑║║╣╷╔↓↑╣╷╔║║↓←╚╔╩╔→╴↑║╣║╗←╶→╦╗╩╣↓╶→╗╚╩╔→╴↓╠╦╴╚╩→←╩╗╚╔→╶5↑╠╠╷╣↑╝3→╦╣╷╚╣↓↑╦═╗╝╶←↓╝╩║╔→╶←╔╝╚╣↑╶→╣╗╵═╚↑↓║╚═╣╷↓→╦╣↑╩╝╶→╝╔═╩↑╴↑╗╚╣║↑╶→═╩╔═→╴↓╠╗╠╩→╵→═╝╣╷═←2→╩╔╣↑╩╴←╚╣╷══←3↑╠╗╴╔║↓↓║╝╚╣╷←↓╝╠╷╚═→←╠║║╔→╵→═╝╣╔→╶→╩╔╦→╣╵↑╣╷╔║╚→↑╦═╗╚→╶→╩╔═╝↑╴→╣╷╚╗╝←→╣╷╚╗║↓→═╦═╗╵↓→╦╣↑╠╝╵←╚║╔╩╷→→╗╚╩║↑╴2←╔╠╴║╝←2↑╠╷╗╚╗↓2→╝╠╷╗╚→→╝╔╣║↑╵3↑╠╔╦╴╩→↑║╣╷═╔↓↓╩╴═╚║↑←╚╗╩╷╚↑↑║╦═╝↑╶2→╩╔╦╴╩→↓╚╩╷══→↑║║╔╩╷→↑║╗╦║↓╶←╚╔╩╗╴←→╦╦→╚╩╴↓║╝╩╷═←→═══╦╴↓↓║╝╠║↑╵↑╣╷═╚╔→→╦╗╩╩→╶↑╠╔╦→╣╵←═╚╠╗╴←→╦╣↑╚╩╴↓║╚╩╔→╴←╠╷║║╝←↓╝╩╷═╚↑→╦╴╚╗║↓↓╚╩╷╗╚→↓╚╗╣╝╶←↓╩╝║╗←╶→═╣╷╝═←←╚╣╗╚↑╶2↓╣║║║↓╶↓╝═╩╷╔↓→╩╦╦→╝╶→╩╷╗╚═→↓╣╚╝╔→╶↓╝╔╝╠╷↓←══╚╣╷←↓╠╦╴╚╣↓↑╦╴╔╝╔↓→╦╗╵║╚→←╚╦╴╚╔→↑║║╗╦╵←↑╔═╦╴║↓↓╚╝║╠╷→↑╔╣╷║║↓↓╩╴╔╚═→→╩╦╗╣↓╶→╝║╔╣╷↓→╩╔╣↑╣╵→╗╝═╠╷↓←╔║╚╩↑╴→╝╠║║↑╴←╚╠╗╴╔↓↑║╠╷╗║↓↑║╣╔╝↑╶↑╗╩║╗←╶↓╚═╗╠╴↓↑╔╗╚╣╷↓←╚╗╔╣↓╶←══╩╗←╶↑╦╝║║↑╶↓╣╚═╝↑╶↓║╚╝╠↑╴→╩╔══→╴→══╩╷╝↑→╗║╝╦↓╶↓║╩╴╔╚→↓╩╴╔╚╗↓←╔║║╣╵←←═╔╩╗↓╶↑║╔╦╴║↓→╗║╣║↓╶→╩║╔═→╴↓╚╦╴╝═←→╗╚╝╠↑╴→╦╗╵║║↓↓╚╣╷╝═←↓╩╴╚╗╚↑↑╔═╩╷╗↓→═╩╗╴╚↑←╔╚╗╠╴↓→╝╗╚╠↑╴→╩╦╗╩→╶↑╗══╦↓╶↑╠╔╣↑╩╴→══╝╣╷←→═╦╴║╝←→╩╷══╝↑↑╔╦╴╚═→↓║╚═╩╷→↑╔╣╷╚╝↑←═╔╩═→╶↑╔═╗╠╴↓→╣╷╝═╚↑↓╠╣╷╚╩→←╚╠╷══→↓╝╔╩╴═←↓║╚╩╷═→↓╩╴═╚╔→↑╔╝╣╗←╶↓╝╔╝╦↓╶→╩╷═══→↓║╣╵═╚↑↓╚╣║╔→╵↓╠╣↑╩╝╶→╩╦╣↑╝╶←═╠╷╚═→↑║╗╦╝╶←→╩╔╣╷╣↓"),
            new CodedMap("Zoltun Kulle", "→╗╣↓╶2→═╦╴↓3←═╦↓╶↑╠╷╝↑2↓╩╗↓╶7↑║╣╷←2↓╣╵═←4↑╗╦↓╶→╩╦╗╝═╚║↑4↓║╣↓╶2↑╣╔→╶3←╚╣╷←3↑╗╠↑╵←╔╠→╵5→╣╷╚→2↓╣╝╶←↑╔╩↑╴↓╠═→╵5↓╩╴╚↑4↑╗╩↑╶3↓╚╩↑╴3→╗╩╴←3↓╠╴║↓3←╠╷╝←↓╠╴╚→↓╚╩╷→↓║║║╠╗╠╝↓2←╠╷╚→3→╝╦╴←↑╣╗←╶5→╝╣╷←3→╩╷═→2←╩╷╔↓5←╠╷║↓↓╠╴║╝╩║╣╣↑╶╶╶↓╠╴╝←↑╔╩╷→→═╩╣╷╴╚║╣╷╠↑╵3←═╩↑╶↓╣║↓╶←╔╩╴←↑╣╣║║╗←╔╚↓╠╝↑╵→╦╗╠╝╝╚╗←↑║╔╝╣╗╠↑╚6↑╦═→╶↓╚═╦╴╩╴╦╵═╩↑╶2↓║╣╵←2↑╔╦╴↓2↑╗╠╷↓2↑╠╷╗↓3→╣╗╵←2←╔╣╵←↑║╣║╣╷╠╷╝╩↑╶╶4→╣╷║↓←╩╗←╶3→╝╠↑╴3←╦╚→╶3→═╣╷↓2→╦╴╝←↑╦╴═←2↓╝╩╷←←╚╣╷═╠╷╩╗╩→╶╶→╩╷╗╝╔╣╩╦╴↓╶╶→╝╦╴╚╣╠╷╦╴╚→╶→╝╠╷→5↑╦╝↑╶4←╚╠↑╴2→╣║↑╵2→╩╔╣╔╗╝║↓2→╗╠╴↓5↑╦╗↓╶→╦╝↑╵↓║╩╣║║╣╠╷→╵╶╶↓╩╦╴╚╦╴╣╝╶╶╔↓↑╠╔╗╣║╚╝↑→═╝╣╣╣╷╩╷╚↑╶╶↓╚╝╔╩╠↑╗╝↓╠╦╝║╗╚╝←2←╚╦╴←→╩╷╝↑→╗╠╦╣║╔╩↑╴╵╵╵2↑║╣↑╶5→╩╗╴←2→╣╷╝←2←═╠↑╵→╦╗╠╝║║║↓4↓╝╦↓╶→╣╷║╝╩╷╚╣╣╷←╶2↑╦╴╚↑4→╝╦→╶4↓╝╩↑╶↑╗╠╠╗╴╵╦╵╩║↑╶↓╚╦→╵2↑║╠↑╴2→╣╔→╵→╝║║╣╗╦╚←2←═╠╷↓←╩╷╩╷╦╚╗║╠→╵╶↓╣╵╠╷╝═╩╦╝↑╶╶↓╝╔╩╴╠╣╠╷╝↑╵╶2↓╚╣╷↓2↓╩═→╶→╩╦╗╝═╔╝←2↓║╩→╶→╦═→╵2↑╗╦╵←2→═╩↑╴→╣╷╚╗╩╣║╦→╵╶╶←╩╗╦╚╚║╗←2→╗╩→╶→═╗╚╩╔╗╣↓↓╠╗╚╣╚═╗↓2→═╦→╵↑╗╔╝╩╗╔╠↓←╦╝╔╠╚═╗↓→╦╴╚→↑╣║╦╣╷║╠╴║↓╶╶←═╦╩╴╶╔╣╵╩╗←╶↓╣╵═╩╷═╩╠╗╴←╶←═╩╷←↓╩╩╷╗╠╴╩╴╶╚╗←→╦╦═╝╔→╚╝→═╝╔╦╦→╚╝3↑╣╷═←←╔╝╚╣╗╠↑╚2←╚╦→╶↓╝╚╗╩╗╔╠↓2←╚╠╷→5←╔╣↓╶←╔╣╵╔╝╦╵╩╦→╶╶↑╠╗╴←↓╝╦╵←→╩╔╗╣╚╝╔→↓╠╗╠╝╝╚╗←3↑╔╣╷↓→╦╗╠╝╚╗║↓←╔╝╔╣╩→╔╚↓╚╣↑╵↓║╩╴←←╦╵╠║╠╷╣╷╚╝↑╵←═╦╵←↑║║║╠╷╣╷╠╴╠╴↓↓╠╣║╗╚╝╚↑2→╦╗╵↓↑╣╷╔↓↓╩╴═←↓║╣╣╣╵╶╶═╔╣↓╶↓╣╣╝╔╚╔║↓2→═╣↑╵→╣╷║╝╩╗╩╷╠↑╵╶↑╦╴╔↓↑╠╷═→←╠╷╚╗╝╦╠╴╣╵╶←←╦╝╶←↑╠╦╴╴═╔╣╵╠║↑╵2→╝╣↑╶←╔╠╴↓↑╣╣╗╚║↑╔╚↓║║╣╚╣╠╠╷→╴╵╶↓╝═╔╣╝╔╩←→╩╔╗╣║╝═←↓╣╚→╶↓╚╝╠╣╔╦╦→╴╵╵╶←╚╔╝╠╦╗╝←↓╠╴╩╴╚╗╦║╩╴╶←←╦╵╩╔╩╷═╦╴╚→╶←╩╗╦╚╔║║↓2←═╚║╠╔╗╣↓↑╗═╚╣╣↑╔╚→═╩╷→←╚╔═╦╗╚╩→←╚╣↑╶↑╗╠╠╷╩╷╣╷║╵║↓↓╠╴╝╩╷╚╣╷╠╷╝←↑╣║↑╶"),
        };
       

        public static List<char> TopFacing = new List<char>{
            '║',
            '╵',
            '↑','↓',
            '╚','╝',
            '╣','╠','╩',
            '╬'
        };
        public static List<char> RightFacing = new List<char>{
            '═',
            '╶',
            '→','←',
            '╚','╔',
            '╠','╩','╦',
            '╬'
        };
        public static List<char> DownFacing = new List<char>{
            '║',
            '╷',
            '↑','↓',
            '╔','╗',
            '╣','╠','╦',
            '╬'
        };
        public static List<char> LeftFacing = new List<char>{
            '═',
            '╴',
            '→','←',
            '╝','╗',
            '╣','╩','╦',
            '╬'
        };

        public const int GridSize = 100;
        public const int GridMiddle = 50;

        private StringBuilder textBuilder;
        private IFont TextFont;
        private IFont WhiteFont;
        private IFont RedFont;
        public bool Show { get; set; }
        public IKeyEvent ToggleKeyEvent { get; set; }
        public string LastMap;
        public char[,] Display = new char[30,30];
        public SortedSet<SceneEntry> ScenesOnTheScreen = new SortedSet<SceneEntry>(new ByCoordinate());
        public int SceneSize = 0;
        public Key HotKey
        {
            get { return ToggleKeyEvent.Key; }
            set { ToggleKeyEvent = Hud.Input.CreateKeyEvent(true, value, false, false, false); }
        }
        public HashSet<string> SceneDebug = new HashSet<string>();
        public string CurrentSnapshot;
        public string Identifier = "";
        public string LastSnapshot = "";
        public List<char[,]> CandidateGrids = new List<char[,]>();
        public bool CandidateGridsAreValid = false;
        public int OldCandidateCount = 0;
        public int Tiles = 0;
        public int Chars = 0;

        public MapKnowledge()
        {
            Enabled = true;
        }
        public override void Load(IController hud)
        {
            base.Load(hud);

            HotKey = Key.F11;
            Show = false;
            //TextFont = Hud.Render.CreateFont("Consolas", 8, 120, 200, 200, 200, true, false, false);
            TextFont = Hud.Render.CreateFont("Consolas", 15, 120, 200, 200, 200, true, false, false);
            WhiteFont = Hud.Render.CreateFont("Consolas", 15, 120, 200, 200, 200, true, false, false);
            RedFont = Hud.Render.CreateFont("Consolas", 15, 120, 255, 0, 0, true, false, false);
            //WhiteFont = Hud.Render.CreateFont("Consolas", 20, 255, 200, 200, 200, true, false, false);
            //RedFont = Hud.Render.CreateFont("Consolas", 20, 255, 255, 0, 0, true, false, false);
            textBuilder = new StringBuilder();
            
        }
        public void OnKeyEvent(IKeyEvent keyEvent)
        {
            if (keyEvent.IsPressed && ToggleKeyEvent.Matches(keyEvent))
            {
                Show = !Show;
            }
        }
        public void OnNewArea(bool newGame, ISnoArea area)
        {
            //Hud.TextLog.Log("MapKnowledge", "Made by Zy", false, false);
            foreach (var Debug in SceneDebug.ToList())
            {
                if (Debug != LastSnapshot)
                {
                    Hud.TextLog.Log("MapKnowledge", Debug, false, true);
                    LastSnapshot = Debug;
                    SceneDebug.Remove(Debug);
                }
            }
            CandidateGridsAreValid = false;
            CandidateGrids.Clear();
            OldCandidateCount = 0;
            ScenesOnTheScreen.Clear();
            SceneSize = 0;
        }
        private int GCD(int a, int b)
        {
            a = Math.Abs(a);
            b = Math.Abs(b);
            while (a != 0 && b != 0)
            {
                if (a > b)
                    a %= b;
                else
                    b %= a;
            }

            return a == 0 ? b : a;
        }
        private string RemoveExcessSeparator(string Old)
        {
            string Result = Old;
            while (Result.Contains("__"))
            {
                Result = Result.Replace("__", "_");
            }
            return Result;
        }
        private SceneEntry TranslateName(SceneEntry Input)
        {
            SceneEntry Result = Input;
            if (Input.SceneName == "")
                return Result;

            //name
            foreach (MapTemplate maptemplate in MapTemplateList)
            {
                if (Input.SceneName.Contains(maptemplate.SceneName_))
                {
                    Result.Mapname = maptemplate.Name_;
                    Result.SceneName = Result.SceneName.Replace(maptemplate.SceneName_, "");
                }
                if (Input.SceneName.Contains("_fire"))
                {
                    Result.Mapname = "Westmarch Ruins";
                    Result.SceneName = Result.SceneName.Replace("_fire", "");
                }
            }
            //entrance exit
            Result.SceneName = RemoveExcessSeparator(Result.SceneName);
            if (Input.SceneName.Contains("entrance"))
            {
                Result.entrance = true;
                Result.SceneName = Result.SceneName.Replace("entrance", "");
            }
            if (Input.SceneName.Contains("exit"))
            {
                Result.exit = true;
                Result.SceneName = Result.SceneName.Replace("exit", "");
            }
            Result.SceneName = RemoveExcessSeparator(Result.SceneName);
            if (Input.SceneName.Contains("elbow"))
            {
                Result.elbow = true;
                Result.SceneName = Result.SceneName.Replace("elbow", "");
            }
            Result.SceneName = RemoveExcessSeparator(Result.SceneName);
            //Type
            foreach (SceneType scenetype in SceneTypeList)
            {
                if (Input.SceneName.Contains(scenetype.Name_))
                {
                    Result.Type = scenetype.Type_;
                    Result.SceneName = Result.SceneName.Replace(scenetype.Name_, "");
                }
            }
            if (Result.Type == '0')//didnt work so remove _
            {
                foreach (SceneType scenetype in SceneTypeList)
                {
                    string NewName = scenetype.Name_;
                    NewName = NewName.TrimEnd('_');
                    if (Input.SceneName.Contains(NewName))
                    {
                        Result.Type = scenetype.Type_;
                        Result.SceneName = Result.SceneName.Replace(NewName, "");
                    }
                }
            }
            Result.SceneName = RemoveExcessSeparator(Result.SceneName);
            if (Result.Type == '╵')
            {
                Result.deadend = true;
                if (Result.entrance || Result.exit)
                {
                    Result.Type = '↑';
                }
            }
            else if (Result.Type == '╶')
            {
                Result.deadend = true;
                if (Result.entrance || Result.exit)
                {
                    Result.Type = '→';
                }
            }
            else if (Result.Type == '╷')
            {
                Result.deadend = true;
                if (Result.entrance || Result.exit)
                {
                    Result.Type = '↓';
                }
            }
            else if (Result.Type == '╴')
            {
                Result.deadend = true;
                if (Result.entrance || Result.exit)
                {
                    Result.Type = '←';
                }
            }

            return Result;
        }
        private bool[] DirectionOf(char c)
        {
            //up right down left
            bool[] a = new bool[4] { false, false, false, false };
            a[0] = (c == '║' || c == '╵' || c == '↑' || c == '╚' || c == '╝' || c == '╣' || c == '╠' || c == '╩' || c == '╬');
            a[1] = (c == '═' || c == '╶' || c == '→' || c == '╚' || c == '╔' || c == '╠' || c == '╩' || c == '╦' || c == '╬');
            a[2] = (c == '║' || c == '╷' || c == '↓' || c == '╗' || c == '╔' || c == '╠' || c == '╣' || c == '╦' || c == '╬');
            a[3] = (c == '═' || c == '╴' || c == '←' || c == '╗' || c == '╝' || c == '╩' || c == '╣' || c == '╦' || c == '╬');

            return a;
        }
        private string GetMapName(SortedSet<SceneEntry> AdjustedScenesOnTheScreen)
        {
            int max = 0;
            string MapName = "";
            Dictionary<string, int> MapNameScores = new Dictionary<string, int>();

            foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen)
            {
                List<string> Names = new List<string>(MapNameScores.Keys);
                bool found = false;
                foreach (string Name in Names)
                {
                    if (Name == sceneentry.Mapname)
                    {
                        found = true;
                        MapNameScores[Name] = MapNameScores[Name] + 1;
                    }
                }
                if (!found)
                {
                    if (sceneentry.Mapname != null)
                        MapNameScores.Add(sceneentry.Mapname, 1);
                }
            }

            foreach (KeyValuePair<string, int> kvp in MapNameScores)
            {
                if (kvp.Value > max)
                {
                    max = kvp.Value;
                    MapName = kvp.Key;
                }
            }

            return MapName;
        }
        private SortedSet<SceneEntry> TranslateScenes(SortedSet<SceneEntry> AdjustedScenesOnTheScreen, MapTemplate Map)
        {
            SortedSet<SceneEntry> TranslatedScenesOnTheScreen = new SortedSet<SceneEntry>(new ByCoordinate());
            Tiles = 0;
            Chars = 0;
            if (Map.Maptype_ == MapType.Normal)
            {
                foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen)
                {
                    if (sceneentry != null)
                    {
                        TranslatedScenesOnTheScreen.Add(sceneentry);
                        if (!sceneentry.deadend)
                        {
                            Tiles++;
                        }
                        Chars++;
                    }
                }
            }
            else if (Map.Maptype_ == MapType.FourCorner)
            {
                //all four corner maps should have <10 Tiles
                for (int i = 0; i < 10; i++)
                {
                    bool found = false; //need to restart loop if we found something
                    for (int TemplateSize = 4; TemplateSize > 0; TemplateSize--)
                    {
                        foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen)
                        {
                            //tile has 3 adjacent scenes so start matching it
                            bool match = false;
                            bool matchR = false;
                            bool matchD = false;
                            bool matchDR = false;
                            SceneEntry Scene = sceneentry;
                            SceneEntry SceneR = sceneentry;
                            SceneEntry SceneD = sceneentry;
                            SceneEntry SceneDR = sceneentry;
                            int IndicatorX = sceneentry.X;
                            int IndicatorY = sceneentry.Y;

                            List<TemplateMatch>[,] TemplateMatches = new List<TemplateMatch>[4, 3];//direction, matching size
                            for (int l = 0; l < 4; l++)
                            {
                                for (int m = 0; m < 3; m++)
                                {
                                    TemplateMatches[l, m] = new List<TemplateMatch>();
                                }
                            }
                            TemplateMatch MatchingTemplate = new TemplateMatch();
                            bool foundTemplate = false;

                            for (int j = 0; j < 4; j++)
                            {
                                match = false;
                                matchR = false;
                                matchD = false;
                                matchDR = false;
                                Scene = sceneentry;
                                SceneR = sceneentry;
                                SceneD = sceneentry;
                                SceneDR = sceneentry;
                                if (j == 0)
                                {
                                    match = true;
                                    Scene = sceneentry;
                                }
                                else if (j == 1)
                                {
                                    matchR = true;
                                    SceneR = sceneentry;
                                }
                                else if (j == 2)
                                {
                                    matchD = true;
                                    SceneD = sceneentry;
                                }
                                else if (j == 3)
                                {
                                    matchDR = true;
                                    SceneDR = sceneentry;
                                }
                                foreach (SceneEntry adjacentscene in AdjustedScenesOnTheScreen)
                                {
                                    if (j == 0)
                                    {
                                        if ((adjacentscene.X == IndicatorX) && (adjacentscene.Y == IndicatorY + 1))//R
                                        {
                                            SceneR = adjacentscene;
                                            matchR = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX + 1) && (adjacentscene.Y == IndicatorY))//D
                                        {
                                            SceneD = adjacentscene;
                                            matchD = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX + 1) && (adjacentscene.Y == IndicatorY + 1))//DR
                                        {
                                            SceneDR = adjacentscene;
                                            matchDR = true;
                                        }
                                    }
                                    else if (j == 1)
                                    {
                                        if ((adjacentscene.X == IndicatorX) && (adjacentscene.Y == IndicatorY - 1))//L
                                        {
                                            Scene = adjacentscene;
                                            match = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX + 1) && (adjacentscene.Y == IndicatorY - 1))//DL
                                        {
                                            SceneD = adjacentscene;
                                            matchD = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX + 1) && (adjacentscene.Y == IndicatorY))//D
                                        {
                                            SceneDR = adjacentscene;
                                            matchDR = true;
                                        }
                                    }
                                    else if (j == 2)
                                    {
                                        if ((adjacentscene.X == IndicatorX - 1) && (adjacentscene.Y == IndicatorY))//T
                                        {
                                            Scene = adjacentscene;
                                            match = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX - 1) && (adjacentscene.Y == IndicatorY + 1))//TR
                                        {
                                            SceneR = adjacentscene;
                                            matchR = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX) && (adjacentscene.Y == IndicatorY + 1))//R
                                        {
                                            SceneDR = adjacentscene;
                                            matchDR = true;
                                        }
                                    }
                                    else if (j == 3)
                                    {
                                        if ((adjacentscene.X == IndicatorX - 1) && (adjacentscene.Y == IndicatorY - 1))//TL
                                        {
                                            Scene = adjacentscene;
                                            match = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX - 1) && (adjacentscene.Y == IndicatorY))//T
                                        {
                                            SceneR = adjacentscene;
                                            matchR = true;
                                        }
                                        if ((adjacentscene.X == IndicatorX) && (adjacentscene.Y == IndicatorY - 1))//L
                                        {
                                            SceneD = adjacentscene;
                                            matchD = true;
                                        }
                                    }
                                }
                                foreach (FourCornerTemplate template in FourCornerTemplateList)
                                {

                                    if (template.Type1_ != '0' && match == true)
                                    {
                                        if (Scene.Type != template.Type1_ || Scene.elbow != template.Elbow1_)
                                        {
                                            continue;
                                        }
                                    }
                                    if (template.Type2_ != '0' && matchR == true)
                                    {
                                        if (SceneR.Type != template.Type2_ || SceneR.elbow != template.Elbow2_)
                                        {
                                            continue;
                                        }
                                    }
                                    if (template.Type3_ != '0' && matchD == true)
                                    {
                                        if (SceneD.Type != template.Type3_ || SceneD.elbow != template.Elbow3_)
                                        {
                                            continue;
                                        }
                                    }
                                    if (template.Type4_ != '0' && matchDR == true)
                                    {
                                        if (SceneDR.Type != template.Type4_ || SceneDR.elbow != template.Elbow4_)
                                        {
                                            continue;
                                        }
                                    }

                                    int PlaceholdersInTemplate = 0;
                                    if (template.Type1_ == '0')
                                    {
                                        PlaceholdersInTemplate++;
                                    }
                                    if (template.Type2_ == '0')
                                    {
                                        PlaceholdersInTemplate++;
                                    }
                                    if (template.Type3_ == '0')
                                    {
                                        PlaceholdersInTemplate++;
                                    }
                                    if (template.Type4_ == '0')
                                    {
                                        PlaceholdersInTemplate++;
                                    }
                                    if (j == 0)
                                    {
                                        if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 0)
                                        {
                                            //textBuilder.AppendFormat("asdf[0, 2]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[0, 2].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR ||
                                                    match && matchR && matchD ||
                                                    match && matchR && matchDR ||
                                                    match && matchD && matchDR ||
                                                    matchR && matchD && matchDR)
                                        {
                                            //textBuilder.AppendFormat("asdf[0, 1]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[0, 1].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 2 ||
                                            PlaceholdersInTemplate == 0 &&
                                                   (match && matchR ||
                                                    match && matchD ||
                                                    match && matchDR ||
                                                    matchR && matchD ||
                                                    matchR && matchDR ||
                                                    matchD && matchDR))
                                        {
                                            //textBuilder.AppendFormat("asdf[0, 0]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[0, 0].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                    }
                                    else if (j == 1)
                                    {
                                        if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 0)
                                        {
                                            //textBuilder.AppendFormat("asdf[1, 2]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[1, 2].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR ||
                                                    match && matchR && matchD ||
                                                    match && matchR && matchDR ||
                                                    match && matchD && matchDR ||
                                                    matchR && matchD && matchDR)
                                        {
                                            //textBuilder.AppendFormat("asdf[1,1]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[1, 1].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 2 ||
                                            PlaceholdersInTemplate == 0 &&
                                                   (match && matchR ||
                                                    match && matchD ||
                                                    match && matchDR ||
                                                    matchR && matchD ||
                                                    matchR && matchDR ||
                                                    matchD && matchDR))
                                        {
                                            //textBuilder.AppendFormat("asdf[1, 0]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[1, 0].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                    }
                                    else if (j == 2)
                                    {
                                        if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 0)
                                        {
                                            //textBuilder.AppendFormat("asdf[2, 2]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[2, 2].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR ||
                                                    match && matchR && matchD ||
                                                    match && matchR && matchDR ||
                                                    match && matchD && matchDR ||
                                                    matchR && matchD && matchDR)
                                        {
                                            //textBuilder.AppendFormat("asdf[2, 1]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[2, 1].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 2 ||
                                            PlaceholdersInTemplate == 0 &&
                                                   (match && matchR ||
                                                    match && matchD ||
                                                    match && matchDR ||
                                                    matchR && matchD ||
                                                    matchR && matchDR ||
                                                    matchD && matchDR))
                                        {
                                            //textBuilder.AppendFormat("asdf[2, 0]:");
                                            //textBuilder.AppendLine();
                                            TemplateMatches[2, 0].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                    }
                                    else if (j == 3)
                                    {
                                        if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 0)
                                        {
                                            TemplateMatches[3, 2].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR ||
                                                    match && matchR && matchD ||
                                                    match && matchR && matchDR ||
                                                    match && matchD && matchDR ||
                                                    matchR && matchD && matchDR)
                                        {
                                            TemplateMatches[3, 1].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                        else if (match && matchR && matchD && matchDR && PlaceholdersInTemplate == 2 ||
                                            PlaceholdersInTemplate == 0 &&
                                                   (match && matchR ||
                                                    match && matchD ||
                                                    match && matchDR ||
                                                    matchR && matchD ||
                                                    matchR && matchDR ||
                                                    matchD && matchDR))
                                        {
                                            TemplateMatches[3, 0].Add(new TemplateMatch(template, match, matchR, matchD, matchDR, Scene, SceneR, SceneD, SceneDR));
                                        }
                                    }
                                }

                            }

                            HashSet<FourCornerTemplate>[,] TemplateMatchesHash = new HashSet<FourCornerTemplate>[4, 3];//direction, matching size
                            HashSet<FourCornerTemplate>[] TemplateMatchesRow = new HashSet<FourCornerTemplate>[3];
                            for (int m = 0; m < 3; m++)
                            {
                                for (int l = 0; l < 4; l++)
                                {
                                    TemplateMatchesHash[l, m] = new HashSet<FourCornerTemplate>();
                                }
                                TemplateMatchesRow[m] = new HashSet<FourCornerTemplate>();
                            }

                            for (int m = 0; m < 3; m++)
                            {
                                for (int l = 0; l < 4; l++)
                                {
                                    foreach (TemplateMatch temp in (TemplateMatches[l, m]))
                                    {
                                        TemplateMatchesHash[l, m].Add(temp.Template_);
                                        TemplateMatchesRow[m].Add(temp.Template_);
                                    }
                                }
                            }

                            for (int m = 2; m >= 0; m--)
                            {
                                for (int l = 0; l < 4; l++)
                                {
                                    if (TemplateMatchesHash[l, m].Count() == 1 && TemplateMatchesRow[m].Count() == 1 && TemplateSize == (m + 2))
                                    {
                                        MatchingTemplate = TemplateMatches[l, m].First();
                                        foundTemplate = true;
                                    }
                                }
                            }

                            if (foundTemplate)
                            {

                                bool entrance = false;
                                bool exit = false;
                                if (MatchingTemplate.match_)
                                {
                                    entrance = entrance || MatchingTemplate.Scene_.entrance;
                                    exit = exit || MatchingTemplate.Scene_.exit;
                                }
                                if (MatchingTemplate.matchR_)
                                {
                                    entrance = entrance || MatchingTemplate.SceneR_.entrance;
                                    exit = exit || MatchingTemplate.SceneR_.exit;
                                }
                                if (MatchingTemplate.matchD_)
                                {
                                    entrance = entrance || MatchingTemplate.SceneD_.entrance;
                                    exit = exit || MatchingTemplate.SceneD_.exit;
                                }
                                if (MatchingTemplate.matchDR_)
                                {
                                    entrance = entrance || MatchingTemplate.SceneDR_.entrance;
                                    exit = exit || MatchingTemplate.SceneDR_.exit;
                                }
                                char Result = MatchingTemplate.Template_.Result_;
                                if (Result == '╵')
                                {
                                    if (entrance || exit)
                                    {
                                        Result = '↑';
                                    }
                                }
                                else if (Result == '╶')
                                {
                                    if (entrance || exit)
                                    {
                                        Result = '→';
                                    }
                                }
                                else if (Result == '╷')
                                {
                                    if (entrance || exit)
                                    {
                                        Result = '↓';
                                    }
                                }
                                else if (Result == '╴')
                                {
                                    if (entrance || exit)
                                    {
                                        Result = '←';
                                    }
                                }
                                SceneEntry Newsceneentry = new SceneEntry();
                                Newsceneentry.Type = Result;
                                Newsceneentry.entrance = entrance;
                                Newsceneentry.exit = exit;
                                Newsceneentry.deadend = MatchingTemplate.Template_.ResultDeadend_;
                                Newsceneentry.elbow = false;
                                if (MatchingTemplate.match_)
                                {
                                    Newsceneentry.SceneName = MatchingTemplate.Scene_.SceneName;
                                    Newsceneentry.Mapname = MatchingTemplate.Scene_.Mapname;
                                    Newsceneentry.PosX = MatchingTemplate.Scene_.PosX;
                                    Newsceneentry.PosY = MatchingTemplate.Scene_.PosY;
                                    Newsceneentry.X = (MatchingTemplate.Scene_.X) / 2;
                                    Newsceneentry.Y = (MatchingTemplate.Scene_.Y) / 2;
                                }
                                else if (MatchingTemplate.matchR_)
                                {
                                    Newsceneentry.SceneName = MatchingTemplate.SceneR_.SceneName;
                                    Newsceneentry.Mapname = MatchingTemplate.SceneR_.Mapname;
                                    Newsceneentry.PosX = MatchingTemplate.SceneR_.PosX;
                                    Newsceneentry.PosY = MatchingTemplate.SceneR_.PosY;
                                    Newsceneentry.X = (MatchingTemplate.SceneR_.X) / 2;
                                    Newsceneentry.Y = (MatchingTemplate.SceneR_.Y) / 2;
                                }
                                else if (MatchingTemplate.matchD_)
                                {
                                    Newsceneentry.SceneName = MatchingTemplate.SceneD_.SceneName;
                                    Newsceneentry.Mapname = MatchingTemplate.SceneD_.Mapname;
                                    Newsceneentry.PosX = MatchingTemplate.SceneD_.PosX;
                                    Newsceneentry.PosY = MatchingTemplate.SceneD_.PosY;
                                    Newsceneentry.X = (MatchingTemplate.SceneD_.X) / 2;
                                    Newsceneentry.Y = (MatchingTemplate.SceneD_.Y) / 2;
                                }
                                else if (MatchingTemplate.matchDR_)
                                {
                                    Newsceneentry.SceneName = MatchingTemplate.SceneDR_.SceneName;
                                    Newsceneentry.Mapname = MatchingTemplate.SceneDR_.Mapname;
                                    Newsceneentry.PosX = MatchingTemplate.SceneDR_.PosX;
                                    Newsceneentry.PosY = MatchingTemplate.SceneDR_.PosY;
                                    Newsceneentry.X = (MatchingTemplate.SceneDR_.X) / 2;
                                    Newsceneentry.Y = (MatchingTemplate.SceneDR_.Y) / 2;
                                }

                                if (MatchingTemplate.Template_.Type1_ != '0' && MatchingTemplate.match_ == true)
                                    AdjustedScenesOnTheScreen.Remove(MatchingTemplate.Scene_);
                                if (MatchingTemplate.Template_.Type2_ != '0' && MatchingTemplate.matchR_ == true)
                                    AdjustedScenesOnTheScreen.Remove(MatchingTemplate.SceneR_);
                                if (MatchingTemplate.Template_.Type3_ != '0' && MatchingTemplate.matchD_ == true)
                                    AdjustedScenesOnTheScreen.Remove(MatchingTemplate.SceneD_);
                                if (MatchingTemplate.Template_.Type4_ != '0' && MatchingTemplate.matchDR_ == true)
                                    AdjustedScenesOnTheScreen.Remove(MatchingTemplate.SceneDR_);

                                TranslatedScenesOnTheScreen.Add(Newsceneentry);
                                found = true;
                                break;
                            }
                            if (found)
                            {
                                break;
                            }
                        }
                        if (found)
                        {
                            break;
                        }
                    }
                }
                foreach (SceneEntry sceneentry in TranslatedScenesOnTheScreen)
                {
                    if (sceneentry != null)
                    {
                        if (!sceneentry.deadend)
                        {
                            Tiles++;
                        }
                        Chars++;
                    }
                }
            }

            return TranslatedScenesOnTheScreen;
        }
        private string CalculateCodedMap(SortedSet<SceneEntry> TranslatedScenesOnTheScreen)
        {
            string CurrentMapCoded = "";
            List<Tuple<int, int, char>> AlreadyVisited = new List<Tuple<int, int, char>>();
            bool FoundEntrance = false;
            bool TileDoesntExist = false;

            foreach (SceneEntry sceneentry in TranslatedScenesOnTheScreen)
            {
                if (sceneentry.entrance)
                {
                    CurrentMapCoded += sceneentry.Type;
                    AlreadyVisited.Add(new Tuple<int, int, char>(sceneentry.X, sceneentry.Y, sceneentry.Type));
                    FoundEntrance = true;
                }
            }
            if (!FoundEntrance)
            {
                return "";
            }
            for (int j = 0; j < 100; j++)
            {
                int NewX = 0;
                int NewY = 0;
                List<Tuple<int, int, Direction>> OpenSlots = new List<Tuple<int, int, Direction>>();
                //find all open slots
                foreach (Tuple<int, int, char> open in AlreadyVisited)
                {
                    for (Direction i = Direction.Top; i < (Direction)4; i++)//check all 4 directions to see if it is connected on the closed list
                    {
                        if (DirectionOf(open.Item3)[(int)i])
                        {
                            NewX = open.Item1;
                            NewY = open.Item2;
                            if (i == Direction.Top)
                            {
                                NewX--;
                            }
                            else if (i == Direction.Right)
                            {
                                NewY++;
                            }
                            else if (i == Direction.Down)
                            {
                                NewX++;
                            }
                            else if (i == Direction.Left)
                            {
                                NewY--;
                            }
                            //check if that spot is already visited
                            bool alreadyvisited = false;
                            foreach (Tuple<int, int, Char> closed in AlreadyVisited)
                            {
                                if (closed.Item1 == NewX && closed.Item2 == NewY)
                                {
                                    alreadyvisited = true;
                                    break;
                                }
                            }
                            if (!alreadyvisited)
                            {
                                OpenSlots.Add(new Tuple<int, int, Direction>(open.Item1, open.Item2, i));
                            }
                        }
                    }
                }
                //find best open slot
                if (OpenSlots.Count() == 0)
                    break;
                Tuple<int, int, Direction> NextSlot = OpenSlots.First();

                for (int i = 0; i < OpenSlots.Count(); i++)
                {
                    if (OpenSlots[i].Item1 == NextSlot.Item1 && OpenSlots[i].Item2 == NextSlot.Item2 && OpenSlots[i].Item3 == NextSlot.Item3)
                    {
                        continue;
                    }

                    //Is OpenSlots[i] a better slot
                    if (OpenSlots[i].Item3 < NextSlot.Item3)//lower is better
                    {
                        NextSlot = OpenSlots[i];
                    }
                    else if (OpenSlots[i].Item3 == NextSlot.Item3)
                    {
                        if (OpenSlots[i].Item1 < NextSlot.Item1)//top direction is x--
                        {
                            NextSlot = OpenSlots[i];
                        }
                        else if (OpenSlots[i].Item1 == NextSlot.Item1)
                        {
                            if (OpenSlots[i].Item2 < NextSlot.Item2)//left direction is y--
                            {
                                NextSlot = OpenSlots[i];
                            }
                        }
                    }
                }
                //NextSlot is the best open slot
                //see if anything connects to it
                NewX = NextSlot.Item1;
                NewY = NextSlot.Item2;
                if (NextSlot.Item3 == Direction.Top)
                {
                    NewX--;
                }
                else if (NextSlot.Item3 == Direction.Right)
                {
                    NewY++;
                }
                else if (NextSlot.Item3 == Direction.Down)
                {
                    NewX++;
                }
                else if (NextSlot.Item3 == Direction.Left)
                {
                    NewY--;
                }

                bool found = false;
                foreach (SceneEntry sceneentry in TranslatedScenesOnTheScreen)
                {
                    if (sceneentry.X == NewX && sceneentry.Y == NewY)
                    {
                        //tile connected to the slot exists
                        //add it to the open list

                        found = true;
                        if (sceneentry.exit)
                        {
                            if (sceneentry.Type == '↑')
                            {
                                CurrentMapCoded += '↓';
                            }
                            else if (sceneentry.Type == '→')
                            {
                                CurrentMapCoded += '←';
                            }
                            else if (sceneentry.Type == '↓')
                            {
                                CurrentMapCoded += '↑';
                            }
                            else if (sceneentry.Type == '←')
                            {
                                CurrentMapCoded += '→';
                            }
                        }
                        else
                        {
                            CurrentMapCoded += sceneentry.Type;
                        }
                        AlreadyVisited.Add(new Tuple<int, int, char>(sceneentry.X, sceneentry.Y, sceneentry.Type));
                    }
                }
                if (!found)
                {
                    TileDoesntExist = true;
                    break;
                }
                if (TileDoesntExist)
                {
                    break;
                }
            }

            return CurrentMapCoded;
        }
        public bool BuildCandidateGrids(List<LayoutEntry> Candidates)
        {
            foreach (LayoutEntry candidate in Candidates)
            {
                char[,] DummyGrid = new char[GridSize, GridSize];
                for (int i = 0; i < GridSize; i++)
                {
                    for (int j = 0; j < GridSize; j++)
                    {
                        DummyGrid[i, j] = ' ';
                    }
                }

                DummyGrid[GridMiddle, GridMiddle] = candidate.Layout.First();
                int k = 1;
                while (k < candidate.Layout.Count())
                {
                    Direction Connection = Direction.Top;
                    for (int l = 0; l < 4; l++)
                    {
                        bool found = false;
                        for (int i = 0; i < GridSize; i++)
                        {
                            for (int j = 0; j < GridSize; j++)
                            {
                                if (DummyGrid[i, j] == '↑')
                                {
                                    if (Connection == Direction.Top && (i == GridMiddle && j == GridMiddle) && DummyGrid[i - 1, j] == ' ')//middle of the grid means entrance
                                    {
                                        DummyGrid[i - 1, j] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Down && (i != GridMiddle && j != GridMiddle) && DummyGrid[i + 1, j] == ' ')
                                    {
                                        DummyGrid[i + 1, j] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                }
                                else if (DummyGrid[i, j] == '→')
                                {
                                    if (Connection == Direction.Right && (i == GridMiddle && j == GridMiddle) && DummyGrid[i, j + 1] == ' ')
                                    {
                                        DummyGrid[i, j + 1] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Left && (i != GridMiddle && j != GridMiddle) && DummyGrid[i, j - 1] == ' ')
                                    {
                                        DummyGrid[i, j - 1] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                }
                                else if (DummyGrid[i, j] == '↓')
                                {
                                    if (Connection == Direction.Down && (i == GridMiddle && j == GridMiddle) && DummyGrid[i + 1, j] == ' ')
                                    {
                                        DummyGrid[i + 1, j] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Top && (i != GridMiddle && j != GridMiddle) && DummyGrid[i - 1, j] == ' ')
                                    {
                                        DummyGrid[i - 1, j] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                }
                                else if (DummyGrid[i, j] == '←')
                                {
                                    if (Connection == Direction.Left && (i == GridMiddle && j == GridMiddle) && DummyGrid[i, j - 1] == ' ')
                                    {
                                        DummyGrid[i, j - 1] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Right && (i != GridMiddle && j != GridMiddle) && DummyGrid[i, j + 1] == ' ')
                                    {
                                        DummyGrid[i, j + 1] = candidate.Layout[k];
                                        found = true;
                                        break;
                                    }
                                }
                                else if (Connection == Direction.Top && TopFacing.Contains(DummyGrid[i, j]) && DummyGrid[i - 1, j] == ' ')
                                {
                                    DummyGrid[i - 1, j] = candidate.Layout[k];
                                    found = true;
                                    break;
                                }
                                else if (Connection == Direction.Right && RightFacing.Contains(DummyGrid[i, j]) && DummyGrid[i, j + 1] == ' ')
                                {
                                    DummyGrid[i, j + 1] = candidate.Layout[k];
                                    found = true;
                                    break;
                                }
                                else if (Connection == Direction.Down && DownFacing.Contains(DummyGrid[i, j]) && DummyGrid[i + 1, j] == ' ')
                                {
                                    DummyGrid[i + 1, j] = candidate.Layout[k];
                                    found = true;
                                    break;
                                }
                                else if (Connection == Direction.Left && LeftFacing.Contains(DummyGrid[i, j]) && DummyGrid[i, j - 1] == ' ')
                                {
                                    DummyGrid[i, j - 1] = candidate.Layout[k];
                                    found = true;
                                    break;
                                }
                            }
                            if (found)
                            {
                                break;
                            }
                        }
                        Connection++;
                        if (found)
                        {
                            break;
                        }
                    }
                    k++;
                }
                CandidateGrids.Add(DummyGrid);

            }
            return false;
        }

        public void PaintTopInGame(ClipState clipState)
        {
            //float x = Hud.Window.Size.Width * 0.85f;
            //float y = Hud.Window.Size.Height * 0.25f;
            float x = Hud.Window.Size.Width * 0.75f;
            float y = Hud.Window.Size.Height * 0.1f;
            string MapName = "";
            int MeX = 0;
            int MeY = 0;
            int EntranceX = 0;
            int EntranceY = 0;
            int ExitX = 0;
            int ExitY = 0;
            List<MatchingResult> OpenSlotResults = new List<MatchingResult>();
            MapTemplate Map = new MapTemplate();

            SortedSet<SceneEntry> AdjustedScenesOnTheScreen = new SortedSet<SceneEntry>(new ByCoordinate());
            SortedSet<SceneEntry> TranslatedScenesOnTheScreen = new SortedSet<SceneEntry>(new ByCoordinate());

            if (clipState != ClipState.BeforeClip)
                return;
            if (Hud.Render.UiHidden)
                return;
            if (Hud.Game.SpecialArea != SpecialArea.GreaterRift)
                return;

            textBuilder.Clear();
            var actors = Hud.Game.Actors;
            foreach (var actor in actors)
            {
                if (actor == null) continue;
                if (actor.Scene == null) continue;
                if (actor.Scene.SnoScene == null) continue;
                SceneEntry New = new SceneEntry(actor.Scene.SnoScene.Code, "", actor.Scene.PosX, actor.Scene.PosY, 0, 0, '0');

                bool NewEntry = true;
                foreach (SceneEntry sceneentry in ScenesOnTheScreen)
                {
                    if (sceneentry.SceneName == New.SceneName &&
                       sceneentry.PosX == New.PosX &&
                       sceneentry.PosY == New.PosY)
                    {
                        NewEntry = false;
                    }
                }
                if (NewEntry)
                {
                    if (New != null)
                    {
                        if (!New.SceneName.Contains("filler"))
                        {
                            ScenesOnTheScreen.Add(New);
                        }
                    }
                    if (New.SceneName.Contains("exit"))
                    {
                        Identifier = "" + actor.Scene.SceneId;
                    }
                }
            }

            foreach (SceneEntry sceneentry in ScenesOnTheScreen)
            {
                if (sceneentry != null)
                    AdjustedScenesOnTheScreen.Add(TranslateName(sceneentry));
            }
            MapName = GetMapName(AdjustedScenesOnTheScreen);

            foreach (MapTemplate maptemplate in MapTemplateList)
            {
                if (maptemplate.Name_ == MapName)
                {
                    Map = maptemplate;
                }
            }

            foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen.ToList())
            {
                if (sceneentry.Mapname != MapName)
                {
                    AdjustedScenesOnTheScreen.Remove(sceneentry);
                }
            }
            if (Show)
            {
                foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen)
                {
                    textBuilder.AppendFormat("{0}: {1},{2},{3},{4},{5},{6},{7}", sceneentry.SceneName, sceneentry.X, sceneentry.Y, sceneentry.Type, sceneentry.elbow, sceneentry.PosX, sceneentry.PosY, sceneentry.Mapname);
                    textBuilder.AppendLine();
                }
            }
            if (AdjustedScenesOnTheScreen.Count() == 0)
            {
                return;
            }
            foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen)
            {
                if (SceneSize == 0)
                {
                    SceneSize = (int)sceneentry.PosX;
                }
                else
                {
                    if (sceneentry.PosX > 0)
                    {
                        SceneSize = GCD(SceneSize, (int)sceneentry.PosX);
                    }
                    if (sceneentry.PosY > 0)
                    {
                        SceneSize = GCD(SceneSize, (int)sceneentry.PosY);
                    }
                }
            }
            /*if (Show)
            {
                textBuilder.AppendFormat("SceneSize: {0}", SceneSize);
                textBuilder.AppendLine();
            }*/
            foreach (SceneEntry sceneentry in ScenesOnTheScreen)
            {
                sceneentry.X = (int)Math.Round(sceneentry.PosX / SceneSize);
                sceneentry.Y = (int)Math.Round(sceneentry.PosY / SceneSize);
            }

            TranslatedScenesOnTheScreen = TranslateScenes(AdjustedScenesOnTheScreen, Map);

            //textBuilder.AppendFormat("Tiles: {0}", Tiles);
            //textBuilder.AppendLine();
            //textBuilder.AppendFormat("Chars: {0}", Chars);
            //textBuilder.AppendLine();

            for (int i = 0; i < 30; i++)
            {
                for (int j = 0; j < 30; j++)
                {
                    Display[i, j] = '_';
                }
            }

            foreach (SceneEntry sceneentry in TranslatedScenesOnTheScreen)
            {
                if (sceneentry.X >= 0 && sceneentry.X < 30 && sceneentry.Y >= 0 && sceneentry.Y < 30)
                {
                    Display[sceneentry.X, sceneentry.Y] = sceneentry.Type;

                    if (sceneentry.entrance)
                    {
                        EntranceX = sceneentry.X;
                        EntranceY = sceneentry.Y;
                    }
                    if (sceneentry.exit)
                    {
                        ExitX = sceneentry.X;
                        ExitY = sceneentry.Y;
                    }
                    if (sceneentry.exit && sceneentry.Type == '↑')
                    {
                        Display[sceneentry.X, sceneentry.Y] = '↓';
                    }
                    else if (sceneentry.exit && sceneentry.Type == '→')
                    {
                        Display[sceneentry.X, sceneentry.Y] = '←';
                    }
                    else if (sceneentry.exit && sceneentry.Type == '↓')
                    {
                        Display[sceneentry.X, sceneentry.Y] = '↑';
                    }
                    else if (sceneentry.exit && sceneentry.Type == '←')
                    {
                        Display[sceneentry.X, sceneentry.Y] = '→';
                    }
                    if (Hud.Game.Me != null && Hud.Game.Me.Scene != null && Hud.Game.Me.Scene.SnoScene != null)
                    {
                        if (Hud.Game.Me.Scene.PosX == sceneentry.PosX && Hud.Game.Me.Scene.PosY == sceneentry.PosY)
                        {
                            MeX = sceneentry.X;
                            MeY = sceneentry.Y;
                        }
                    }

                }
            }

            int maxX = 0;
            int maxY = 0;
            for (int i = 0; i < 30; i++)
            {
                for (int j = 0; j < 30; j++)
                {
                    if (Display[i, j] != '_')
                    {
                        if (i > maxX)
                            maxX = i;
                        if (j > maxY)
                            maxY = j;
                    }
                }
            }

            //textBuilder.AppendLine();
            if (Show)
            {
                for (int i = 0; i <= maxX; i++)
                {
                    for (int j = 0; j <= maxY; j++)
                    {
                        if (Display[i, j] == '_')
                            textBuilder.AppendFormat(" ");
                        //else if (Display[i, j] == '╖' || Display[i, j] == '╕' || Display[i, j] == '╒' || Display[i, j] == '╜')
                        //    textBuilder.AppendFormat("·");
                        else
                            textBuilder.AppendFormat("{0}", Display[i, j]);
                    }
                    textBuilder.AppendLine();
                }
            }
            //DEBUG
            if (Show)
            {
                textBuilder.AppendFormat("AdjustedScenesOnTheScreen");
                textBuilder.AppendLine();
                foreach (SceneEntry sceneentry in AdjustedScenesOnTheScreen)
                {
                    textBuilder.AppendFormat("{0}: {1},{2},{3},{4},{5},{6},{7}", sceneentry.SceneName, sceneentry.X, sceneentry.Y, sceneentry.Type, sceneentry.elbow, sceneentry.PosX, sceneentry.PosY, sceneentry.Mapname);
                    textBuilder.AppendLine();
                }
                textBuilder.AppendFormat("TranslatedScenesOnTheScreen");
                textBuilder.AppendLine();
                foreach (SceneEntry sceneentry in TranslatedScenesOnTheScreen)
                {
                    textBuilder.AppendFormat("{0}: {1},{2},{3},{4},{5},{6},{7}", sceneentry.SceneName, sceneentry.X, sceneentry.Y, sceneentry.Type, sceneentry.elbow, sceneentry.PosX, sceneentry.PosY, sceneentry.Mapname);
                    textBuilder.AppendLine();
                }
            }

            int ValidEntrances = 0;
            int ValidExits = 0;
            int[] Directions = new int[4] { 0, 0, 0, 0 };
            foreach (SceneEntry sceneentry in TranslatedScenesOnTheScreen)
            {
                if (sceneentry.entrance)
                {
                    ValidEntrances++;
                }
                if (sceneentry.exit)
                {
                    ValidExits++;
                }
                bool[] Connections = DirectionOf(sceneentry.Type);
                if (Connections[0])
                    Directions[0]++;
                if (Connections[1])
                    Directions[1]++;
                if (Connections[2])
                    Directions[2]++;
                if (Connections[3])
                    Directions[3]++;
            }
            if (Show)
            {
                textBuilder.AppendFormat("Directions: {0},{1},{2},{3}", Directions[0], Directions[1], Directions[2], Directions[3]);
                textBuilder.AppendLine();
            }

            for (int i = 0; i < CodedMaps.Count(); i++)
            {
                if (!CodedMaps[i].IsSplit)
                {
                    CodedMaps[i].Split();
                }
            }

            string CurrentMapCoded = "";

            CurrentMapCoded = CalculateCodedMap(TranslatedScenesOnTheScreen);

            //textBuilder.AppendFormat("CurrentMapCoded: {0}", CurrentMapCoded);
            //textBuilder.AppendLine();

            if (CurrentMapCoded != "")
            {
                List<LayoutEntry> Candidates = new List<LayoutEntry>();
                foreach (CodedMap codedmap in CodedMaps)
                {
                    if (codedmap.Name == MapName)
                    {
                        foreach (LayoutEntry codedlayout in codedmap.Layouts)
                        {
                            if (codedlayout.Layout.Count() >= CurrentMapCoded.Count())//only consider layouts that are big enough
                            {
                                if (codedlayout.Layout.Substring(0, CurrentMapCoded.Count()) == CurrentMapCoded)//coded string of the map matches
                                {
                                    Candidates.Add(new LayoutEntry(codedlayout.Count, codedlayout.Layout));
                                }
                            }
                        }
                    }
                }

                if (Show)
                {
                    textBuilder.AppendFormat("Candidates: {0}", Candidates.Count());
                    textBuilder.AppendLine();
                }

                if (Candidates.Count() != OldCandidateCount)
                {
                    CandidateGridsAreValid = false;
                }
                OldCandidateCount = Candidates.Count();

                if (Show)
                {
                    foreach (LayoutEntry candidate in Candidates)
                    {
                        textBuilder.AppendFormat(": {0}", candidate.Layout);
                        textBuilder.AppendLine();
                    }
                }


                if (Candidates.Count() > 1000)
                {
                    textBuilder.AppendFormat("too many candidates");
                    textBuilder.AppendLine();
                }
                else if (Candidates.Count() == 0)
                {
                    //textBuilder.AppendFormat("no data");
                    //textBuilder.AppendLine();
                }
                else
                {
                    if (!CandidateGridsAreValid)
                    {
                        CandidateGrids.Clear();
                        bool error = BuildCandidateGrids(Candidates);
                        if (error || CandidateGrids.Count() == 0)
                        {
                            textBuilder.AppendFormat("ERROR in BuildCandidateGrids {0}", error);
                            textBuilder.AppendLine();
                            CandidateGridsAreValid = false;
                        }
                        else
                        {
                            CandidateGridsAreValid = true;
                        }
                    }
                    if (CandidateGridsAreValid)
                    {
                        char[,] CurrentGrid = new char[GridSize, GridSize];
                        for (int i = 0; i < GridSize; i++)
                        {
                            for (int j = 0; j < GridSize; j++)
                            {
                                CurrentGrid[i, j] = ' ';
                            }
                        }
                        int OffsetX = GridMiddle - EntranceX;
                        int OffsetY = GridMiddle - EntranceY;
                        for (int i = 0; i <= maxX; i++)
                        {
                            for (int j = 0; j <= maxY; j++)
                            {
                                if (Display[i, j] != '_')
                                {
                                    if ((i + OffsetX) >= 0 && (j + OffsetY) >= 0 && (i + OffsetX) < GridSize && (j + OffsetY) < GridSize)
                                    {
                                        CurrentGrid[i + OffsetX, j + OffsetY] = Display[i, j];
                                    }
                                }
                            }
                        }

                        if (CandidateGrids.Count() != Candidates.Count())
                        {
                            textBuilder.AppendFormat("ERROR CandidateGrids.Count() != Candidates.Count()");
                            textBuilder.AppendLine();
                            textBuilder.AppendFormat("CandidateGrids.Count() : {0}  Candidates.Count() : {1}", CandidateGrids.Count(), Candidates.Count());
                            textBuilder.AppendLine();
                            textBuilder.AppendFormat("CandidateGridsAreValid : {0}  OldCandidateCount : {1}", CandidateGridsAreValid, OldCandidateCount);
                            textBuilder.AppendLine();
                        }

                        bool[] IsValid = new bool[CandidateGrids.Count()];
                        for (int i = 0; i < CandidateGrids.Count(); i++)
                        {
                            IsValid[i] = true;
                        }

                        for (int k = 0; k < CandidateGrids.Count(); k++)
                        {
                            for (int i = 0; i < GridSize; i++)
                            {
                                for (int j = 0; j < GridSize; j++)
                                {
                                    if (CurrentGrid[i, j] != ' ')
                                    {
                                        if ((CandidateGrids[k])[i, j] != CurrentGrid[i, j])
                                        {
                                            //textBuilder.AppendFormat("doesnt fit: {0} was {1} should be {2} at {3},{4}", k, (CandidateGrids[k])[i, j], CurrentGrid[i, j], i, j);
                                            //textBuilder.AppendLine();
                                            IsValid[k] = false;
                                        }
                                    }
                                }
                            }
                        }

                        HashSet<Tuple<int, int>> OpenSlots = new HashSet<Tuple<int, int>>();
                        Direction Connection = Direction.Top;
                        for (int l = 0; l < 4; l++)
                        {
                            bool found = false;
                            for (int i = 0; i < GridSize; i++)
                            {
                                for (int j = 0; j < GridSize; j++)
                                {
                                    if (CurrentGrid[i, j] == '↑')
                                    {
                                        if (Connection == Direction.Top && (i == GridMiddle && j == GridMiddle) && CurrentGrid[i - 1, j] == ' ')//middle of the grid means entrance
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i - 1, j));
                                            found = true;
                                            break;
                                        }
                                        else if (Connection == Direction.Down && (i != GridMiddle && j != GridMiddle) && CurrentGrid[i + 1, j] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i + 1, j));
                                            found = true;
                                            break;
                                        }
                                    }
                                    else if (CurrentGrid[i, j] == '→')
                                    {
                                        if (Connection == Direction.Right && (i == GridMiddle && j == GridMiddle) && CurrentGrid[i, j + 1] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i, j + 1));
                                            found = true;
                                            break;
                                        }
                                        else if (Connection == Direction.Left && (i != GridMiddle && j != GridMiddle) && CurrentGrid[i, j - 1] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i, j - 1));
                                            found = true;
                                            break;
                                        }
                                    }
                                    else if (CurrentGrid[i, j] == '↓')
                                    {
                                        if (Connection == Direction.Down && (i == GridMiddle && j == GridMiddle) && CurrentGrid[i + 1, j] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i + 1, j));
                                            found = true;
                                            break;
                                        }
                                        else if (Connection == Direction.Top && (i != GridMiddle && j != GridMiddle) && CurrentGrid[i - 1, j] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i - 1, j));
                                            found = true;
                                            break;
                                        }
                                    }
                                    else if (CurrentGrid[i, j] == '←')
                                    {
                                        if (Connection == Direction.Left && (i == GridMiddle && j == GridMiddle) && CurrentGrid[i, j - 1] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i, j - 1));
                                            found = true;
                                            break;
                                        }
                                        else if (Connection == Direction.Right && (i != GridMiddle && j != GridMiddle) && CurrentGrid[i, j + 1] == ' ')
                                        {
                                            OpenSlots.Add(new Tuple<int, int>(i, j + 1));
                                            found = true;
                                            break;
                                        }
                                    }
                                    else if (Connection == Direction.Top && TopFacing.Contains(CurrentGrid[i, j]) && CurrentGrid[i - 1, j] == ' ')
                                    {
                                        OpenSlots.Add(new Tuple<int, int>(i - 1, j));
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Right && RightFacing.Contains(CurrentGrid[i, j]) && CurrentGrid[i, j + 1] == ' ')
                                    {
                                        OpenSlots.Add(new Tuple<int, int>(i, j + 1));
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Down && DownFacing.Contains(CurrentGrid[i, j]) && CurrentGrid[i + 1, j] == ' ')
                                    {
                                        OpenSlots.Add(new Tuple<int, int>(i + 1, j));
                                        found = true;
                                        break;
                                    }
                                    else if (Connection == Direction.Left && LeftFacing.Contains(CurrentGrid[i, j]) && CurrentGrid[i, j - 1] == ' ')
                                    {
                                        OpenSlots.Add(new Tuple<int, int>(i, j - 1));

                                        found = true;
                                        break;
                                    }
                                }
                                if (found)
                                {
                                    break;
                                }
                            }
                            Connection++;
                        }

                        /*foreach (Tuple<int, int> slot in OpenSlots)
                        {
                            textBuilder.AppendFormat(":{0},{1}", slot.Item1, slot.Item2);
                            textBuilder.AppendLine();
                        }

                        textBuilder.AppendFormat("Open Slots:");
                        foreach (Tuple<int, int> slot in OpenSlots)
                        {
                            textBuilder.AppendFormat(":{0},{1}", slot.Item1, slot.Item2);
                            textBuilder.AppendLine();
                        }*/
                        bool data = false;
                        foreach (Tuple<int, int> slot in OpenSlots)
                        {
                            if (slot.Item1 < 0 || slot.Item1 > GridSize || slot.Item2 < 0 || slot.Item2 > GridSize)
                            {
                                textBuilder.AppendFormat("ERROR slot.Item1 < 0 || slot.Item1 > GridSize || slot.Item2 < 0 || slot.Item2 > GridSize");
                                textBuilder.AppendLine();
                                continue;
                            }

                            int total = 0;
                            List<int> TileCandidatesCount = new List<int>();
                            List<char> TileCandidatesType = new List<char>();
                            for (int i = 0; i < Candidates.Count(); i++)
                            {
                                if (!IsValid[i])
                                {
                                    continue;
                                }
                                if (Candidates[i].Count <= 0)
                                {
                                    textBuilder.AppendFormat("ERROR Candidates[i].Count <= 0");
                                    textBuilder.AppendLine();
                                }
                                bool found = false;
                                for (int j = 0; j < TileCandidatesCount.Count(); j++)
                                {
                                    if (TileCandidatesType[j] == (CandidateGrids[i])[slot.Item1, slot.Item2])
                                    {
                                        TileCandidatesCount[j] += Candidates[i].Count;
                                        total += Candidates[i].Count;
                                        found = true;
                                    }
                                }
                                if (!found)
                                {
                                    TileCandidatesCount.Add(Candidates[i].Count);
                                    TileCandidatesType.Add((CandidateGrids[i])[slot.Item1, slot.Item2]);
                                    total += Candidates[i].Count;
                                }
                            }

                            if (total > 0)
                            {
                                List<Tuple<char, double>> Entry = new List<Tuple<char, double>>();
                                for (int i = 0; i < TileCandidatesCount.Count(); i++)
                                {
                                    Entry.Add(new Tuple<char, double>(TileCandidatesType[i], ((double)TileCandidatesCount[i]) / ((double)total)));
                                }
                                OpenSlotResults.Add(new MatchingResult(slot.Item1 - GridMiddle, slot.Item2 - GridMiddle, Entry));
                                data = true;
                            }
                        }
                        /*if(!data)
                        {
                            textBuilder.AppendFormat("no data");
                            textBuilder.AppendLine();
                        }*/
                    }
                }
            }
            OpenSlotResults.Sort(new ByY());

            List<MatchingResult> OpenSlotResultsLeft = new List<MatchingResult>();
            List<MatchingResult> OpenSlotResultsRight = new List<MatchingResult>();

            int m = 0;
            foreach (MatchingResult matchingresult in OpenSlotResults)
            {
                if (m >= (int)(OpenSlotResults.Count() / 2))
                {
                    OpenSlotResultsRight.Add(matchingresult);
                }
                else
                {
                    OpenSlotResultsLeft.Add(matchingresult);
                }
                m++;
            }
            OpenSlotResultsLeft.Sort(new ByX());
            OpenSlotResultsRight.Sort(new ByX());

            foreach (MatchingResult matchingresult in OpenSlotResultsRight)
            {
                matchingresult.Data.Sort(new ByPercent());
                foreach (Tuple<char, double> entry in matchingresult.Data)
                {
                    textBuilder.AppendFormat("{0}: {1:P0}", entry.Item1, entry.Item2);
                    textBuilder.AppendLine();
                }
                textBuilder.AppendLine();
            }

            float Spacingx = -Hud.Window.Size.Width * 0.06f;
            float Spacingy = 0.0f;

            var layout = TextFont.GetTextLayout(textBuilder.ToString());
            TextFont.DrawText(layout, x, y);
            textBuilder.Clear();

            foreach (MatchingResult matchingresult in OpenSlotResultsLeft)
            {
                matchingresult.Data.Sort(new ByPercent());
                foreach (Tuple<char, double> entry in matchingresult.Data)
                {
                    textBuilder.AppendFormat("{0}: {1:P0}", entry.Item1, entry.Item2);
                    textBuilder.AppendLine();
                }
                textBuilder.AppendLine();
            }

            layout = TextFont.GetTextLayout(textBuilder.ToString());
            TextFont.DrawText(layout, x + Spacingx, y + Spacingy);
            textBuilder.Clear();

            CurrentSnapshot = "";
            CurrentSnapshot += MapName + System.Environment.NewLine;
            CurrentSnapshot += Identifier + System.Environment.NewLine;
            float deltax = Hud.Window.Size.Width * 0.0079f;
            float deltay = Hud.Window.Size.Height * 0.029f;
            //float deltax = Hud.Window.Size.Width * 0.0093f;//20 size
            //float deltay = Hud.Window.Size.Height * 0.0378f;

            for (int i = 0; i <= maxX; i++)
            {
                for (int j = 0; j <= maxY; j++)
                {
                    if (Display[i, j] != '_')
                    {
                        textBuilder.AppendFormat("{0}", Display[i, j]);
                        layout = WhiteFont.GetTextLayout(textBuilder.ToString());
                        if (i == MeX && j == MeY)
                        {
                            if (Show)
                            {
                                RedFont.DrawText(layout, x + (j + 1) * deltax, y + i * deltay);
                            }
                        }
                        else
                        {
                            if (Show)
                            {
                                WhiteFont.DrawText(layout, x + (j + 1) * deltax, y + i * deltay);
                            }
                        }
                        CurrentSnapshot += Display[i, j];
                        textBuilder.Clear();
                    }
                    else
                    {
                        CurrentSnapshot += " ";
                    }
                }
                CurrentSnapshot += System.Environment.NewLine;
            }
            if (ValidEntrances == 1 && ValidExits == 1 && Directions[0] == Directions[2] && Directions[1] == Directions[3])
            {
                SceneDebug.Add(CurrentSnapshot);
            }

            
        }
    }
}
 
 